
==================== FINAL INTERFACE ====================
2018-07-20 18:09:25.181294 UTC

interface bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX:Data.Trie.BigEndianPatricia.Internal 8001
  interface hash: f5c7dee04e3b39552a4ad5c992474cf8
  ABI hash: f59b3bce4a1944305edd233cbf1f02b7
  export-list hash: 4b0053b84e77b5caaee3c9f9de90fe29
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f49f82a814ed150d1189e7f2d2e73878
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Trie.BigEndianPatricia.Internal.adjustBy
  Data.Trie.BigEndianPatricia.Internal.alterBy
  Data.Trie.BigEndianPatricia.Internal.alterBy_
  Data.Trie.BigEndianPatricia.Internal.contextualFilterMap
  Data.Trie.BigEndianPatricia.Internal.contextualMap
  Data.Trie.BigEndianPatricia.Internal.contextualMap'
  Data.Trie.BigEndianPatricia.Internal.contextualMapBy
  Data.Trie.BigEndianPatricia.Internal.empty
  Data.Trie.BigEndianPatricia.Internal.filterMap
  Data.Trie.BigEndianPatricia.Internal.foldrWithKey
  Data.Trie.BigEndianPatricia.Internal.lookupBy_
  Data.Trie.BigEndianPatricia.Internal.mapBy
  Data.Trie.BigEndianPatricia.Internal.match_
  Data.Trie.BigEndianPatricia.Internal.matches_
  Data.Trie.BigEndianPatricia.Internal.maxAssoc
  Data.Trie.BigEndianPatricia.Internal.mergeBy
  Data.Trie.BigEndianPatricia.Internal.minAssoc
  Data.Trie.BigEndianPatricia.Internal.null
  Data.Trie.BigEndianPatricia.Internal.showTrie
  Data.Trie.BigEndianPatricia.Internal.singleton
  Data.Trie.BigEndianPatricia.Internal.size
  Data.Trie.BigEndianPatricia.Internal.submap
  Data.Trie.BigEndianPatricia.Internal.toListBy
  Data.Trie.BigEndianPatricia.Internal.updateMaxViewBy
  Data.Trie.BigEndianPatricia.Internal.updateMinViewBy
  Data.Trie.BigEndianPatricia.Internal.Trie
module dependencies: Data.Trie.BigEndianPatricia.BitTwiddle
                     Data.Trie.ByteStringInternal
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Functor 67cebb006c069ea73adcd2d468cdb0dc
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:Data.Monoid 6756b44c170e445e254f1a1c3e59ccfa
import  -/  base-4.9.0.0:Data.Semigroup 4aef0ef9e6e6826b7d625ca18dc999aa
import  -/  base-4.9.0.0:Data.Traversable 578f976513fd28b7f58c156ea20c192a
import  -/  base-4.9.0.0:Data.Tuple 84c2bcc75b7a239341ae2f88cce9d8d7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.0.0:GHC.Exts 8dde1ef8f2283d1c13b06a4e51aded72
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary 6874ec1640b9c9e26e0b523287f2c847
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Class 8597f8b1c2ab4e12727292e0fd7fcc19
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Get.Internal 2e7605525151d1d4905dbc0c729d189c
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString 94d879de7c0c4c728d40df2175a8ec14
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Internal c4a5d5c11e9c7b86fbb578dc42b94086
import  -/  Data.Trie.BigEndianPatricia.BitTwiddle 3ea1914db60aded0f26d319a23805c2b
  exports: 6840dd155f43ad2f487af4b51ee3b319
  Mask 8842595f2fafc2054fef6fc85a3c5b09
  Prefix 4a2e8b98a9994ac472a7e5fa81bbce4a
  branchMask 64438c3c134bbb43d0e3dcdc021a5dce
  mask 44486fe2c05b5a747e13c1aebfef1123
  nomatch 9c9efba126bf8a6cdcf379e341e38621
  shorter 57981be8f64015f96d5349f1e56dbdd2
  zero bef20c6a2bebea335cd5221dd3967ad7
import  -/  Data.Trie.ByteStringInternal bf2bb815b22e2d3f05bd812f82c519b8
  exports: d460a1523e9dff7fa14b4e8b29362579
  ByteStringElem ff1646aaf324aacc05edeb026668a023
  breakMaximalPrefix 13a392144f72e74533e51bc06ca38c06
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
addDependentFile "C:\Users\ulyssesp\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.1\lib\include\ghcversion.h"
addDependentFile ".stack-work\dist\b7fec021\build\autogen\cabal_macros.h"
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie ::
    GHC.Base.Applicative Data.Trie.BigEndianPatricia.Internal.Trie
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.BigEndianPatricia.Internal.Trie
                  Data.Trie.BigEndianPatricia.Internal.$fFunctorTrie
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$cpure
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c<*>
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c*>
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c<* -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$c*> ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie b) ->
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c<*>
                   @ b
                   @ b
                   (Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$cfmap
                      @ a
                      @ (b -> b)
                      (\ (ds :: a) (eta2 :: b) -> eta2)
                      eta)
                   eta1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$c<* ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie b) ->
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c<*>
                   @ b
                   @ a
                   (Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$cfmap
                      @ a
                      @ (b -> a)
                      (GHC.Base.const @ a @ b)
                      eta)
                   eta1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$c<*> ::
    Data.Trie.BigEndianPatricia.Internal.Trie (a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (m1 :: Data.Trie.BigEndianPatricia.Internal.Trie (a -> b))
                   (m2 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                   @ (a -> b)
                   @ b
                   m1
                   (\ (x1 :: a -> b) ->
                    Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                      @ a
                      @ b
                      m2
                      (\ (x2 :: a) ->
                       Data.Trie.BigEndianPatricia.Internal.Arc
                         @ b
                         __NULL
                         Data.ByteString.Internal.$fMonoidByteString3
                         0#
                         0#
                         (GHC.Base.Just @ b (x1 x2))
                         (Data.Trie.BigEndianPatricia.Internal.Empty @ b)))) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$c>>= ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> (a -> Data.Trie.BigEndianPatricia.Internal.Trie b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <S,1*U><L,C(U)> -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$cfmap ::
    (a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Trie.BigEndianPatricia.Internal.Trie b
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> Data.Trie.BigEndianPatricia.Internal.Empty @ b
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing
                            -> case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Nothing @ b)
                                 dt4 }
                            GHC.Base.Just v
                            -> case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Just @ b (f v))
                                 dt4 } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> case go l of dt2 { DEFAULT ->
                          case go r of dt3 { DEFAULT ->
                          Data.Trie.BigEndianPatricia.Internal.Branch
                            @ b
                            dt
                            dt1
                            dt2
                            dt3 } } }
                 } in
                 go eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$cpure ::
    a -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$creturn -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fApplicativeTrie_$creturn ::
    a -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 1,
     Unfolding: (\ @ a ->
                 Data.Trie.BigEndianPatricia.Internal.singleton
                   @ a
                   Data.ByteString.empty) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fBinaryTrie ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Class.Binary
      (Data.Trie.BigEndianPatricia.Internal.Trie a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(U(A,U)),U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dBinary :: Data.Binary.Class.Binary a).
                  @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                  (Data.Trie.BigEndianPatricia.Internal.$fBinaryTrie_$cput
                     @ a
                     $dBinary)
                  (Data.Trie.BigEndianPatricia.Internal.$fBinaryTrie_$cget
                     @ a
                     $dBinary)
                  (Data.Trie.BigEndianPatricia.Internal.$fBinaryTrie_$cputList
                     @ a
                     $dBinary) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fBinaryTrie1 ::
    Data.Binary.Class.Binary a =>
    forall r.
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success
         (Data.Trie.BigEndianPatricia.Internal.Trie a) r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3,
     Strictness: <L,U(A,U,A)><S(LLLS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   @ r
                   (w1 :: Data.ByteString.Internal.ByteString)
                   (w2 :: Data.Binary.Get.Internal.Success
                            (Data.Trie.BigEndianPatricia.Internal.Trie a) r) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.BigEndianPatricia.Internal.$w$cget
                   @ a
                   w
                   @ r
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fBinaryTrie_$cget ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get
      (Data.Trie.BigEndianPatricia.Internal.Trie a)
  {- Arity: 3,
     Strictness: <L,U(A,U,A)><S(LLLS),1*U(U,U,U,U)><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fBinaryTrie1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Binary.Class.Binary a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                               <Data.Trie.BigEndianPatricia.Internal.Trie a>_R)) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fBinaryTrie_$cput ::
    Data.Binary.Class.Binary a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> Data.Binary.Put.Put
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(U(A,U)),A,A)><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 case Data.Trie.BigEndianPatricia.Internal.$w$cput
                        @ a
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fBinaryTrie_$cputList ::
    Data.Binary.Class.Binary a =>
    [Data.Trie.BigEndianPatricia.Internal.Trie a]
    -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(A,U)),U,A)> -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fEqTrie ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (Data.Trie.BigEndianPatricia.Internal.Trie a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                  (Data.Trie.BigEndianPatricia.Internal.$fEqTrie_$c== @ a $dEq)
                  (Data.Trie.BigEndianPatricia.Internal.$fEqTrie_$c/= @ a $dEq) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fEqTrie_$c/= ::
    GHC.Classes.Eq a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (b :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 case Data.Trie.BigEndianPatricia.Internal.$fEqTrie_$c==
                        @ a
                        $dEq
                        a1
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fEqTrie_$c== ::
    GHC.Classes.Eq a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie ::
    Data.Foldable.Foldable Data.Trie.BigEndianPatricia.Internal.Trie
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.BigEndianPatricia.Internal.Trie
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfold
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldMap
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldr
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldr'
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldl
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldl'
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldr1
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldl1
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$ctoList
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cnull
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$clength
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$celem
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cmaximum
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cminimum
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$csum
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cproduct -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie1 ::
    GHC.Num.Num a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   lvl43 :: a
                   = GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidProduct1
                 } in
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Monoid.Product a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> lvl43 `cast` (Sym (Data.Monoid.N:Product[0] <a>_R))
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t
                            GHC.Base.Just v
                            -> (GHC.Num.*
                                  @ a
                                  $dNum
                                  v
                                  (go t) `cast` (Data.Monoid.N:Product[0] <a>_R))
                                 `cast`
                               (Sym (Data.Monoid.N:Product[0] <a>_R)) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> (GHC.Num.*
                             @ a
                             $dNum
                             (go l) `cast` (Data.Monoid.N:Product[0] <a>_R)
                             (go r) `cast` (Data.Monoid.N:Product[0] <a>_R))
                            `cast`
                          (Sym (Data.Monoid.N:Product[0] <a>_R)) }
                 } in
                 go eta) -}
d5bbf1a9190155113c6eaa35cab572db
  $fFoldableTrie10 :: a
  {- Strictness: x -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie2 ::
    GHC.Num.Num a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(C(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   lvl43 :: a = GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidSum1
                 } in
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Monoid.Sum a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> lvl43 `cast` (Sym (Data.Monoid.N:Sum[0] <a>_R))
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t
                            GHC.Base.Just v
                            -> (GHC.Num.+
                                  @ a
                                  $dNum
                                  v
                                  (go t) `cast` (Data.Monoid.N:Sum[0] <a>_R))
                                 `cast`
                               (Sym (Data.Monoid.N:Sum[0] <a>_R)) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> (GHC.Num.+
                             @ a
                             $dNum
                             (go l) `cast` (Data.Monoid.N:Sum[0] <a>_R)
                             (go r) `cast` (Data.Monoid.N:Sum[0] <a>_R))
                            `cast`
                          (Sym (Data.Monoid.N:Sum[0] <a>_R)) }
                 } in
                 go eta) -}
6e7f78ef24bd036072ae650cbd66d451
  $fFoldableTrie3 :: a
  {- Strictness: x -}
5b2fcdbdb96dc905961064534f0837b7
  $fFoldableTrie4 :: a
  {- Strictness: x -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie5 ::
    GHC.Classes.Eq a =>
    a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> Data.Monoid.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldMap
                   @ Data.Monoid.Any
                   @ a
                   Data.Monoid.$fMonoidAny
                   (GHC.Classes.== @ a $dEq eta)
                     `cast`
                   (<a>_R ->_R Sym (Data.Monoid.N:Any[0]))) -}
80e54280b3ee6ec401f9762f1edd84ea
  $fFoldableTrie6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f0fa6f0fcec60d8652e006fa5c964554
  $fFoldableTrie7 :: GHC.Types.Int -> a -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><L,A>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (c :: GHC.Types.Int) (ds :: a) ->
                 case c of wild { GHC.Types.I# x ->
                 GHC.Types.I# (GHC.Prim.+# x 1#) }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie8 ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
c6dce90d22025a7693eef54894e77cc3
  $fFoldableTrie9 :: a
  {- Strictness: x -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$celem ::
    GHC.Classes.Eq a =>
    a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie5
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <a>_R
                 ->_R <Data.Trie.BigEndianPatricia.Internal.Trie a>_R
                 ->_R Data.Monoid.N:Any[0]) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfold ::
    GHC.Base.Monoid m =>
    Data.Trie.BigEndianPatricia.Internal.Trie m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie m) ->
                 Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)
                   eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a -> m) -> Data.Trie.BigEndianPatricia.Internal.Trie a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
     Unfolding: (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   lvl43 :: m = GHC.Base.mempty @ m $dMonoid
                 } in
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a -> m
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> lvl43
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t
                            GHC.Base.Just v -> GHC.Base.mappend @ m $dMonoid (f v) (go t) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> GHC.Base.mappend @ m $dMonoid (go l) (go r) }
                 } in
                 go eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldl ::
    (b -> a -> b)
    -> b -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a -> b -> b
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta :: b) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t eta GHC.Base.Just v -> go t (f eta v) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go r (go l eta) }
                 } in
                 go t1 z) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldl' ::
    (b -> a -> b)
    -> b -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z0 :: b)
                   (xs :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> (b -> b) -> b -> b
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta :: b -> b) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t eta
                            GHC.Base.Just v
                            -> let {
                                 k :: b -> b = go t eta
                               } in
                               \ (z :: b) -> case f z v of x1 { DEFAULT -> k x1 } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go l (go r eta) }
                 } in
                 go xs (GHC.Base.id @ b) z0) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldl1 ::
    (a -> a -> a) -> Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> GHC.Base.Maybe a -> GHC.Base.Maybe a
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta :: GHC.Base.Maybe a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t eta
                            GHC.Base.Just v
                            -> go
                                 t
                                 (GHC.Base.Just
                                    @ a
                                    (case eta of wild2 {
                                       GHC.Base.Nothing -> v GHC.Base.Just x -> f x v })) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go r (go l eta) }
                 } in
                 case go xs (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing
                   -> Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie9 @ a
                   GHC.Base.Just v -> v }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldr ::
    (a -> b -> b)
    -> b -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z :: b)
                   (t1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 (Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldMap
                    @ (Data.Monoid.Endo b)
                    @ a
                    (Data.Monoid.$fMonoidEndo @ b)
                    f `cast` (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <b>_R))
                    t1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b>_R)
                   z) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldr' ::
    (a -> b -> b)
    -> b -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z0 :: b)
                   (xs :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> (b -> b) -> b -> b
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta :: b -> b) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t eta
                            GHC.Base.Just v
                            -> go t (\ (z :: b) -> case f v z of x1 { DEFAULT -> eta x1 }) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go r (go l eta) }
                 } in
                 go xs (GHC.Base.id @ b) z0) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cfoldr1 ::
    (a -> a -> a) -> Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> GHC.Base.Maybe a -> GHC.Base.Maybe a
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta :: GHC.Base.Maybe a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t eta
                            GHC.Base.Just v
                            -> GHC.Base.Just
                                 @ a
                                 (case go t eta of wild2 {
                                    GHC.Base.Nothing -> v GHC.Base.Just y -> f v y }) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go l (go r eta) }
                 } in
                 case go xs (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing
                   -> Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie10 @ a
                   GHC.Base.Just v -> v }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$clength ::
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a ->
                 Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldl'
                   @ GHC.Types.Int
                   @ a
                   (Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie7 @ a)
                   Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie6) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cmaximum ::
    GHC.Classes.Ord a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Foldable.Max a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> (GHC.Base.Nothing @ a)
                            `cast`
                          (Sym (Data.Foldable.N:Max[0]) <a>_N)
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t
                            GHC.Base.Just v
                            -> case (go t) `cast` (Data.Foldable.N:Max[0] <a>_N) of wild2 {
                                 GHC.Base.Nothing
                                 -> (GHC.Base.Just @ a v)
                                      `cast`
                                    (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                 GHC.Base.Just ipv
                                 -> case GHC.Classes.>= @ a $dOrd v ipv of wild3 {
                                      GHC.Types.False
                                      -> wild2 `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                      GHC.Types.True
                                      -> (GHC.Base.Just @ a v)
                                           `cast`
                                         (Sym (Data.Foldable.N:Max[0]) <a>_N) } } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> case (go r) `cast` (Data.Foldable.N:Max[0] <a>_N) of wild1 {
                            GHC.Base.Nothing -> go l
                            GHC.Base.Just ipv
                            -> case (go l) `cast` (Data.Foldable.N:Max[0] <a>_N) of wild2 {
                                 GHC.Base.Nothing
                                 -> wild1 `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                 GHC.Base.Just x
                                 -> case GHC.Classes.>= @ a $dOrd x ipv of wild3 {
                                      GHC.Types.False
                                      -> wild1 `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                      GHC.Types.True
                                      -> wild2 `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N) } } } }
                 } in
                 case (go eta) `cast` (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing
                   -> Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie4 @ a
                   GHC.Base.Just v -> v }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cminimum ::
    GHC.Classes.Ord a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Foldable.Min a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> (GHC.Base.Nothing @ a)
                            `cast`
                          (Sym (Data.Foldable.N:Min[0]) <a>_N)
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing -> go t
                            GHC.Base.Just v
                            -> case (go t) `cast` (Data.Foldable.N:Min[0] <a>_N) of wild2 {
                                 GHC.Base.Nothing
                                 -> (GHC.Base.Just @ a v)
                                      `cast`
                                    (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                 GHC.Base.Just ipv
                                 -> case GHC.Classes.<= @ a $dOrd v ipv of wild3 {
                                      GHC.Types.False
                                      -> wild2 `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                      GHC.Types.True
                                      -> (GHC.Base.Just @ a v)
                                           `cast`
                                         (Sym (Data.Foldable.N:Min[0]) <a>_N) } } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> case (go r) `cast` (Data.Foldable.N:Min[0] <a>_N) of wild1 {
                            GHC.Base.Nothing -> go l
                            GHC.Base.Just ipv
                            -> case (go l) `cast` (Data.Foldable.N:Min[0] <a>_N) of wild2 {
                                 GHC.Base.Nothing
                                 -> wild1 `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                 GHC.Base.Just x
                                 -> case GHC.Classes.<= @ a $dOrd x ipv of wild3 {
                                      GHC.Types.False
                                      -> wild1 `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                      GHC.Types.True
                                      -> wild2 `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N) } } } }
                 } in
                 case (go eta) `cast` (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing
                   -> Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie3 @ a
                   GHC.Base.Just v -> v }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cnull ::
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a
                   (t1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie8
                   @ a
                   t1
                   GHC.Types.True) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$cproduct ::
    GHC.Num.Num a => Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Data.Trie.BigEndianPatricia.Internal.Trie a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$csum ::
    GHC.Num.Num a => Data.Trie.BigEndianPatricia.Internal.Trie a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(C(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Data.Trie.BigEndianPatricia.Internal.Trie a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFoldableTrie_$ctoList ::
    Data.Trie.BigEndianPatricia.Internal.Trie a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie_$cfoldr
                      @ a
                      @ b
                      c
                      n
                      t1)) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFunctorTrie ::
    GHC.Base.Functor Data.Trie.BigEndianPatricia.Internal.Trie
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.BigEndianPatricia.Internal.Trie
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$cfmap
                  Data.Trie.BigEndianPatricia.Internal.$fFunctorTrie_$c<$ -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fFunctorTrie_$c<$ ::
    a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie b) ->
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonadTrie ::
    GHC.Base.Monad Data.Trie.BigEndianPatricia.Internal.Trie
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.BigEndianPatricia.Internal.Trie
                  Data.Trie.BigEndianPatricia.Internal.$fMonadTrie_$cp1Monad
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                  Data.Trie.BigEndianPatricia.Internal.$fMonadTrie_$c>>
                  Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$creturn
                  Data.Trie.BigEndianPatricia.Internal.$fMonadTrie_$s$dmfail -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonadTrie_$c>> ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (k :: Data.Trie.BigEndianPatricia.Internal.Trie b) ->
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                   @ a
                   @ b
                   m1
                   (\ (ds :: a) -> k)) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonadTrie_$cp1Monad ::
    GHC.Base.Applicative Data.Trie.BigEndianPatricia.Internal.Trie
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonadTrie_$s$dmfail ::
    GHC.Base.String -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 1, Strictness: <B,U>x,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a (s :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.PtrRepLifted
                   @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                   s) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonoidTrie ::
    GHC.Base.Monoid a =>
    GHC.Base.Monoid (Data.Trie.BigEndianPatricia.Internal.Trie a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dMonoid :: GHC.Base.Monoid a).
                  @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                  (Data.Trie.BigEndianPatricia.Internal.$fMonoidTrie_$cmempty
                     @ a
                     $dMonoid)
                  (Data.Trie.BigEndianPatricia.Internal.$fMonoidTrie_$cmappend
                     @ a
                     $dMonoid)
                  (Data.Trie.BigEndianPatricia.Internal.$fMonoidTrie_$cmconcat
                     @ a
                     $dMonoid) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonoidTrie_$cmappend ::
    GHC.Base.Monoid a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3, Strictness: <L,U(A,C(C1(U)),A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.mergeBy
                   @ a
                   (\ (x :: a) (y :: a)[OneShot] ->
                    GHC.Base.Just @ a (GHC.Base.mappend @ a $dMonoid x y))
                   eta
                   eta1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonoidTrie_$cmconcat ::
    GHC.Base.Monoid a =>
    [Data.Trie.BigEndianPatricia.Internal.Trie a]
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, Strictness: <L,U(A,C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (eta :: [Data.Trie.BigEndianPatricia.Internal.Trie a]) ->
                 let {
                   lvl43 :: a -> a -> GHC.Base.Maybe a {- Arity: 2 -}
                   = \ (x :: a) (y :: a)[OneShot] ->
                     GHC.Base.Just @ a (GHC.Base.mappend @ a $dMonoid x y)
                 } in
                 letrec {
                   go :: [Data.Trie.BigEndianPatricia.Internal.Trie a]
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Data.Trie.BigEndianPatricia.Internal.Trie a]) ->
                     case ds of wild {
                       [] -> Data.Trie.BigEndianPatricia.Internal.Empty @ a
                       : y ys
                       -> Data.Trie.BigEndianPatricia.Internal.mergeBy
                            @ a
                            lvl43
                            y
                            (go ys) }
                 } in
                 go eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fMonoidTrie_$cmempty ::
    GHC.Base.Monoid a => Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) ->
                 Data.Trie.BigEndianPatricia.Internal.Empty @ a) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fSemigroupTrie ::
    Data.Semigroup.Semigroup a =>
    Data.Semigroup.Semigroup
      (Data.Trie.BigEndianPatricia.Internal.Trie a)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,A,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dSemigroup :: Data.Semigroup.Semigroup a).
                  @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                  (Data.Trie.BigEndianPatricia.Internal.$fSemigroupTrie_$c<>
                     @ a
                     $dSemigroup)
                  (Data.Trie.BigEndianPatricia.Internal.$fSemigroupTrie_$csconcat
                     @ a
                     $dSemigroup)
                  (Data.Trie.BigEndianPatricia.Internal.$fSemigroupTrie_$cstimes
                     @ a
                     $dSemigroup) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fSemigroupTrie_$c<> ::
    Data.Semigroup.Semigroup a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3, Strictness: <L,1*U(1*U,A,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dSemigroup :: Data.Semigroup.Semigroup a)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   f :: a -> a -> a = Data.Semigroup.<> @ a $dSemigroup
                 } in
                 Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                   @ a
                   @ a
                   eta
                   (\ (x1 :: a) ->
                    Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie_$c>>=
                      @ a
                      @ a
                      eta1
                      (\ (x2 :: a) ->
                       Data.Trie.BigEndianPatricia.Internal.Arc
                         @ a
                         __NULL
                         Data.ByteString.Internal.$fMonoidByteString3
                         0#
                         0#
                         (GHC.Base.Just @ a (f x1 x2))
                         (Data.Trie.BigEndianPatricia.Internal.Empty @ a)))) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fSemigroupTrie_$csconcat ::
    Data.Semigroup.Semigroup a =>
    Data.List.NonEmpty.NonEmpty
      (Data.Trie.BigEndianPatricia.Internal.Trie a)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, Strictness: <L,U(U,A,A)><S(SS),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Semigroup.Semigroup a)
                   (w1 :: Data.List.NonEmpty.NonEmpty
                            (Data.Trie.BigEndianPatricia.Internal.Trie a)) ->
                 case w1 of ww { Data.List.NonEmpty.:| ww1 ww2 ->
                 Data.Trie.BigEndianPatricia.Internal.$w$csconcat
                   @ a
                   w
                   ww1
                   ww2 }) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fSemigroupTrie_$cstimes ::
    Data.Semigroup.Semigroup a =>
    forall b.
    GHC.Real.Integral b =>
    b
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 4,
     Strictness: <L,U(U,A,A)><S(SLLLLLLLL),U(U,U,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U> -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fShowTrie ::
    GHC.Show.Show a =>
    GHC.Show.Show (Data.Trie.BigEndianPatricia.Internal.Trie a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                  (Data.Trie.BigEndianPatricia.Internal.$fShowTrie_$cshowsPrec
                     @ a
                     $dShow)
                  (Data.Trie.BigEndianPatricia.Internal.$fShowTrie_$cshow @ a $dShow)
                  (Data.Trie.BigEndianPatricia.Internal.$fShowTrie_$cshowList
                     @ a
                     $dShow) -}
15c7ac3b8e3ad36d447ea786cd6198c3
  $fShowTrie1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Data.Trie.fromList "#) -}
013c58a520fdd13bfff3880aeeebffcb
  $fShowTrie2 ::
    Data.ByteString.Internal.ByteString
    -> a
    -> [(Data.ByteString.Internal.ByteString, a)]
    -> [(Data.ByteString.Internal.ByteString, a)]
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a
                   (x :: Data.ByteString.Internal.ByteString)
                   (x1 :: a)[OneShot]
                   (eta :: [(Data.ByteString.Internal.ByteString, a)])[OneShot] ->
                 GHC.Types.:
                   @ (Data.ByteString.Internal.ByteString, a)
                   (x, x1)
                   eta) -}
5e2f9da001d737c7f74a71a359f9b0dc
  $fShowTrie3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "[]"#
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fShowTrie_$cshow ::
    GHC.Show.Show a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Data.Trie.BigEndianPatricia.Internal.$fShowTrie1
                   (case Data.Trie.BigEndianPatricia.Internal.foldrWithKey
                           @ a
                           @ [(Data.ByteString.Internal.ByteString, a)]
                           (Data.Trie.BigEndianPatricia.Internal.$fShowTrie2 @ a)
                           (GHC.Types.[] @ (Data.ByteString.Internal.ByteString, a))
                           x of wild {
                      [] -> Data.Trie.BigEndianPatricia.Internal.$fShowTrie3
                      : x1 xs
                      -> GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.showList__2
                           (case x1 of ww { (,) ww1 ww2 ->
                            GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.shows9
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.shows8
                                 (case ww1 of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww3 ww7 ->
                                  GHC.Show.showLitString
                                    (Data.ByteString.Internal.$wunpackAppendCharsLazy
                                       ww5
                                       ww6
                                       ww3
                                       ww7
                                       (GHC.Types.[] @ GHC.Types.Char))
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.shows8
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.shows7
                                          (GHC.Show.$fShow(,)_$sgo
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.shows6
                                                (letrec {
                                                   showl :: [(Data.ByteString.Internal.ByteString,
                                                              a)]
                                                            -> GHC.Base.String
                                                     {- Arity: 1, Strictness: <S,1*U> -}
                                                   = \ (ds2 :: [(Data.ByteString.Internal.ByteString,
                                                                 a)]) ->
                                                     case ds2 of wild1 {
                                                       []
                                                       -> Data.Trie.BigEndianPatricia.Internal.$fShowTrie_lvl27
                                                       : y ys
                                                       -> GHC.Types.:
                                                            @ GHC.Types.Char
                                                            GHC.Show.shows7
                                                            (case y of ww8 { (,) ww9 ww10 ->
                                                             GHC.Types.:
                                                               @ GHC.Types.Char
                                                               GHC.Show.shows9
                                                               (GHC.Types.:
                                                                  @ GHC.Types.Char
                                                                  GHC.Show.shows8
                                                                  (GHC.Show.showLitString
                                                                     (Data.ByteString.Internal.unpackChars
                                                                        ww9)
                                                                     (GHC.Types.:
                                                                        @ GHC.Types.Char
                                                                        GHC.Show.shows8
                                                                        (GHC.Types.:
                                                                           @ GHC.Types.Char
                                                                           GHC.Show.shows7
                                                                           (GHC.Show.$fShow(,)_$sgo
                                                                              (GHC.Types.:
                                                                                 @ GHC.Types.Char
                                                                                 GHC.Show.shows6
                                                                                 (showl ys))
                                                                              (GHC.Show.showsPrec
                                                                                 @ a
                                                                                 $dShow
                                                                                 GHC.Show.shows22
                                                                                 ww10)
                                                                              (GHC.Types.[]
                                                                                 @ GHC.Show.ShowS)))))) }) }
                                                 } in
                                                 showl xs))
                                             (GHC.Show.showsPrec @ a $dShow GHC.Show.shows22 ww2)
                                             (GHC.Types.[] @ GHC.Show.ShowS)))) })) }) })) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fShowTrie_$cshowList ::
    GHC.Show.Show a =>
    [Data.Trie.BigEndianPatricia.Internal.Trie a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Data.Trie.BigEndianPatricia.Internal.Trie a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (Data.Trie.BigEndianPatricia.Internal.$fShowTrie_$cshowsPrec
                      @ a
                      $dShow
                      GHC.Show.shows22)
                   ls
                   s) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fShowTrie_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Data.Trie.BigEndianPatricia.Internal.$w$cshowsPrec
                   @ a
                   w
                   ww1
                   w2 }) -}
83cfffe8bec29cbd816a232c1bdd4c3c
  $fShowTrie_lvl27 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.showList__1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fTraversableTrie ::
    Data.Traversable.Traversable
      Data.Trie.BigEndianPatricia.Internal.Trie
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.BigEndianPatricia.Internal.Trie
                  Data.Trie.BigEndianPatricia.Internal.$fFunctorTrie
                  Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie
                  Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$ctraverse
                  Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$csequenceA
                  Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$cmapM
                  Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$csequence -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fTraversableTrie_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> m (Data.Trie.BigEndianPatricia.Internal.Trie b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U,1*C1(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fTraversableTrie_$csequence ::
    GHC.Base.Monad m =>
    Data.Trie.BigEndianPatricia.Internal.Trie (m a)
    -> m (Data.Trie.BigEndianPatricia.Internal.Trie a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U,1*C1(U),C(C1(U)),A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie (m a)) ->
                 Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fTraversableTrie_$csequenceA ::
    GHC.Base.Applicative f =>
    Data.Trie.BigEndianPatricia.Internal.Trie (f a)
    -> f (Data.Trie.BigEndianPatricia.Internal.Trie a)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie (f a)) ->
                 Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $fTraversableTrie_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> f (Data.Trie.BigEndianPatricia.Internal.Trie b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(1*U,1*C1(U),C(C1(U)),A,A)><L,C(U)><S,1*U>,
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   lvl43 :: f (Data.Trie.BigEndianPatricia.Internal.Trie b)
                   = GHC.Base.pure
                       @ f
                       $dApplicative
                       @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                       (Data.Trie.BigEndianPatricia.Internal.Empty @ b)
                 } in
                 let {
                   $dFunctor :: GHC.Base.Functor f
                   = GHC.Base.$p1Applicative @ f $dApplicative
                 } in
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> f (Data.Trie.BigEndianPatricia.Internal.Trie b)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> lvl43
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing
                            -> GHC.Base.fmap
                                 @ f
                                 $dFunctor
                                 @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                                 @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                                 (Data.Trie.BigEndianPatricia.Internal.$WArc
                                    @ b
                                    (Data.ByteString.Internal.PS dt dt1 dt2 dt3)
                                    (GHC.Base.Nothing @ b))
                                 (go t)
                            GHC.Base.Just v
                            -> GHC.Base.<*>
                                 @ f
                                 $dApplicative
                                 @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                                 @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                                 (GHC.Base.fmap
                                    @ f
                                    $dFunctor
                                    @ b
                                    @ (Data.Trie.BigEndianPatricia.Internal.Trie b
                                       -> Data.Trie.BigEndianPatricia.Internal.Trie b)
                                    (\ (x :: b)
                                       (eta2 :: Data.Trie.BigEndianPatricia.Internal.Trie b) ->
                                     case eta2 of dt4 { DEFAULT ->
                                     Data.Trie.BigEndianPatricia.Internal.Arc
                                       @ b
                                       dt
                                       dt1
                                       dt2
                                       dt3
                                       (GHC.Base.Just @ b x)
                                       dt4 })
                                    (eta v))
                                 (go t) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> GHC.Base.<*>
                            @ f
                            $dApplicative
                            @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                            @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                            (GHC.Base.fmap
                               @ f
                               $dFunctor
                               @ (Data.Trie.BigEndianPatricia.Internal.Trie b)
                               @ (Data.Trie.BigEndianPatricia.Internal.Trie b
                                  -> Data.Trie.BigEndianPatricia.Internal.Trie b)
                               (Data.Trie.BigEndianPatricia.Internal.$WBranch
                                  @ b
                                  (GHC.Word.W8# dt)
                                  (GHC.Word.W8# dt1))
                               (go l))
                            (go r) }
                 } in
                 go eta1) -}
f6fa77cb40dc868a271cd28c9d1fab28
  $tc'Arc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8743224802262978134##
                   9184828536805839783##
                   Data.Trie.BigEndianPatricia.Internal.$trModule
                   Data.Trie.BigEndianPatricia.Internal.$tc'Arc1) -}
3a2a92bf0186741e2b2a9d3b8de7794f
  $tc'Arc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Arc"#) -}
0d1c88ef708c92d54dbc07d78df7806f
  $tc'Branch :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6762530113212574447##
                   1919928925390347499##
                   Data.Trie.BigEndianPatricia.Internal.$trModule
                   Data.Trie.BigEndianPatricia.Internal.$tc'Branch1) -}
258c4798e6fe9333df7047a001590842
  $tc'Branch1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Branch"#) -}
e8996ebe6048aca3ff7df972eaebbba1
  $tc'Empty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11342695923429161775##
                   5175792891912984833##
                   Data.Trie.BigEndianPatricia.Internal.$trModule
                   Data.Trie.BigEndianPatricia.Internal.$tc'Empty1) -}
cc0a6e598f2cea4194915b27570123f9
  $tc'Empty1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Empty"#) -}
3b62fefdf0cea1cd6dbd35df8237cd49
  $tcTrie :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6047178118994165803##
                   12088455008651788205##
                   Data.Trie.BigEndianPatricia.Internal.$trModule
                   Data.Trie.BigEndianPatricia.Internal.$tcTrie1) -}
80dbb0f9696523cec7570994936a48b8
  $tcTrie1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Trie"#) -}
3425fad847d4000e1e05b6fd81fbb04c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Trie.BigEndianPatricia.Internal.$trModule2
                   Data.Trie.BigEndianPatricia.Internal.$trModule1) -}
afc933c46e9384a0b7f9478b2d8f0d02
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Trie.BigEndianPatricia.Internal"#) -}
e2487eccf4499441eadb44e53d7a1075
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX"#) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $w$cget ::
    Data.Binary.Class.Binary a =>
    forall r.
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success
         (Data.Trie.BigEndianPatricia.Internal.Trie a) r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 6,
     Strictness: <L,U(A,U,A)><L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0] -}
a9cdd0b44d88c10f0755fad281dbeb54
  $w$cput ::
    Data.Binary.Class.Binary a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(U(A,U)),A,A)><S,1*U>,
     Inline: [0] -}
a9cdd0b44d88c10f0755fad281dbeb54
  $w$csconcat ::
    Data.Semigroup.Semigroup a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> [Data.Trie.BigEndianPatricia.Internal.Trie a]
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3, Strictness: <L,U(U,A,A)><S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Semigroup.Semigroup a)
                   (ww :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (ww1 :: [Data.Trie.BigEndianPatricia.Internal.Trie a]) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> [Data.Trie.BigEndianPatricia.Internal.Trie a]
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (b :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (ds1 :: [Data.Trie.BigEndianPatricia.Internal.Trie a]) ->
                     case ds1 of wild1 {
                       [] -> b
                       : c cs
                       -> Data.Trie.BigEndianPatricia.Internal.$fSemigroupTrie_$c<>
                            @ a
                            w
                            b
                            (go c cs) }
                 } in
                 go ww ww1) -}
a9cdd0b44d88c10f0755fad281dbeb54
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 let {
                   eta :: [(Data.ByteString.Internal.ByteString, a)]
                   = Data.Trie.BigEndianPatricia.Internal.foldrWithKey
                       @ a
                       @ [(Data.ByteString.Internal.ByteString, a)]
                       (Data.Trie.BigEndianPatricia.Internal.$fShowTrie2 @ a)
                       (GHC.Types.[] @ (Data.ByteString.Internal.ByteString, a))
                       w1
                 } in
                 let {
                   lvl43 :: (Data.ByteString.Internal.ByteString, a)
                            -> GHC.Base.String -> [GHC.Types.Char]
                     {- Arity: 2 -}
                   = \ (w3 :: (Data.ByteString.Internal.ByteString, a))
                       (w4 :: GHC.Base.String)[OneShot] ->
                     case w3 of ww1 { (,) ww2 ww3 ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       GHC.Show.shows9
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows8
                          (GHC.Show.showLitString
                             (Data.ByteString.Internal.unpackChars ww2)
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows8
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows7
                                   (GHC.Show.$fShow(,)_$sgo
                                      (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w4)
                                      (GHC.Show.showsPrec @ a w GHC.Show.shows22 ww3)
                                      (GHC.Types.[] @ GHC.Show.ShowS)))))) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww 10#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        Data.Trie.BigEndianPatricia.Internal.$fShowTrie1
                        (GHC.Show.showList__
                           @ (Data.ByteString.Internal.ByteString, a)
                           lvl43
                           eta
                           x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Trie.BigEndianPatricia.Internal.$fShowTrie1
                           (GHC.Show.showList__
                              @ (Data.ByteString.Internal.ByteString, a)
                              lvl43
                              eta
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x))) }) -}
8e7e677aaa04ec6786f94a2a3c829f60
  $wadjustBy ::
    (Data.ByteString.Internal.ByteString -> a -> a -> a)
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 6, Strictness: <L,1*C1(C1(U))><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.ByteString.Internal.ByteString -> a -> a -> a)
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: a) ->
                 let {
                   wild :: Data.ByteString.Internal.ByteString
                   = Data.ByteString.Internal.PS ww ww1 ww2 ww3
                 } in
                 let {
                   f :: a -> a = w wild w1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww3 0#) of wild1 {
                   GHC.Types.False
                   -> letrec {
                        go :: Data.ByteString.Internal.ByteString
                              -> Data.Trie.BigEndianPatricia.Internal.Trie a
                              -> Data.Trie.BigEndianPatricia.Internal.Trie a
                          {- Arity: 2, Strictness: <L,U(U,U,U,U)><S,1*U> -}
                        = \ (ds :: Data.ByteString.Internal.ByteString)
                            (ds1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                          case ds1 of wild2 {
                            Data.Trie.BigEndianPatricia.Internal.Empty
                            -> Data.Trie.BigEndianPatricia.Internal.Empty @ a
                            Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 mv t
                            -> case ds of ww5 { Data.ByteString.Internal.PS ww6 ww7 ww8 ww9 ->
                               case Data.Trie.ByteStringInternal.$wbreakMaximalPrefix
                                      dt
                                      dt1
                                      dt2
                                      dt3
                                      ww6
                                      ww7
                                      ww8
                                      ww9 of wild3 { (,,) ds2 k' q' ->
                               case k' of wild4 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<=# dt7 0#) of wild5 {
                                 GHC.Types.False
                                 -> case q' of wild6 { Data.ByteString.Internal.PS dt8 dt9 dt10 dt11 ->
                                    wild2 }
                                 GHC.Types.True
                                 -> case q' of wild6 { Data.ByteString.Internal.PS dt8 dt9 dt10 dt11 ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.<=# dt11 0#) of wild7 {
                                      GHC.Types.False
                                      -> case go wild6 t of dt12 { DEFAULT ->
                                         Data.Trie.BigEndianPatricia.Internal.Arc
                                           @ a
                                           dt
                                           dt1
                                           dt2
                                           dt3
                                           mv
                                           dt12 }
                                      GHC.Types.True
                                      -> case case mv of wild8 {
                                                GHC.Base.Nothing -> GHC.Base.Nothing @ a
                                                GHC.Base.Just x
                                                -> GHC.Base.Just @ a (f x) } of dt12 { DEFAULT ->
                                         Data.Trie.BigEndianPatricia.Internal.Arc
                                           @ a
                                           dt
                                           dt1
                                           dt2
                                           dt3
                                           dt12
                                           t } } } } } } }
                            Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                            -> case Data.Trie.BigEndianPatricia.Internal.errorLogHead
                                      Data.Trie.BigEndianPatricia.Internal.adjustBy1
                                      ds of wild3 { GHC.Word.W8# x# ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.neWord#
                                         (GHC.Prim.narrow8Word#
                                            (GHC.Prim.and#
                                               x#
                                               (GHC.Prim.xor#
                                                  (GHC.Prim.xor#
                                                     (GHC.Prim.minusWord# dt1 1##)
                                                     18446744073709551615##)
                                                  dt1)))
                                         dt) of wild4 {
                                 GHC.Types.False
                                 -> case GHC.Prim.and# x# dt1 of wild5 {
                                      DEFAULT
                                      -> case go ds r of dt2 { DEFAULT ->
                                         Data.Trie.BigEndianPatricia.Internal.Branch
                                           @ a
                                           dt
                                           dt1
                                           l
                                           dt2 }
                                      0##
                                      -> case go ds l of dt2 { DEFAULT ->
                                         Data.Trie.BigEndianPatricia.Internal.Branch
                                           @ a
                                           dt
                                           dt1
                                           dt2
                                           r } }
                                 GHC.Types.True -> wild2 } } }
                      } in
                      go wild
                   GHC.Types.True
                   -> \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                      case ds of wild2 {
                        DEFAULT -> wild2
                        Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                        -> case ds1 of wild3 {
                             GHC.Base.Nothing -> wild2
                             GHC.Base.Just v
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<=# dt3 0#) of wild4 {
                                  GHC.Types.False -> wild2
                                  GHC.Types.True
                                  -> Data.Trie.BigEndianPatricia.Internal.Arc
                                       @ a
                                       dt
                                       dt1
                                       dt2
                                       dt3
                                       (GHC.Base.Just @ a (f v))
                                       t } } } }) -}
35977aa2fdbecbf3bbcd8f5b62399a0f
  $walterBy ::
    (Data.ByteString.Internal.ByteString
     -> a -> GHC.Base.Maybe a -> GHC.Base.Maybe a)
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 6, Strictness: <L,C(C1(C1(U)))><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.ByteString.Internal.ByteString
                         -> a -> GHC.Base.Maybe a -> GHC.Base.Maybe a)
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: a) ->
                 Data.Trie.BigEndianPatricia.Internal.$walterBy_
                   @ a
                   (\ (k :: Data.ByteString.Internal.ByteString)[OneShot]
                      (v :: a)[OneShot]
                      (mv :: GHC.Base.Maybe a)
                      (t :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                    (w k v mv, t))
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
165f7e5662a9e1d8ab1594bf12cd8427
  $walterBy_ ::
    (Data.ByteString.Internal.ByteString
     -> a
     -> GHC.Base.Maybe a
     -> Data.Trie.BigEndianPatricia.Internal.Trie a
     -> (GHC.Base.Maybe a, Data.Trie.BigEndianPatricia.Internal.Trie a))
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 6, Strictness: <L,1*C1(C1(U))><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0] -}
a9cdd0b44d88c10f0755fad281dbeb54
  data Trie a
    = Empty
    | Arc {-# UNPACK #-}Data.ByteString.Internal.ByteString
          !(GHC.Base.Maybe a)
          !(Data.Trie.BigEndianPatricia.Internal.Trie a)
    | Branch {-# UNPACK #-}Data.Trie.BigEndianPatricia.BitTwiddle.Prefix
             {-# UNPACK #-}Data.Trie.BigEndianPatricia.BitTwiddle.Mask
             !(Data.Trie.BigEndianPatricia.Internal.Trie a)
             !(Data.Trie.BigEndianPatricia.Internal.Trie a)
a093594aa7963620862cf753e8e384ba
  adjustBy ::
    (Data.ByteString.Internal.ByteString -> a -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><S(LLLS),1*U(U,U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.ByteString.Internal.ByteString -> a -> a -> a)
                   (w1 :: Data.ByteString.Internal.ByteString)
                   (w2 :: a) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.BigEndianPatricia.Internal.$wadjustBy
                   @ a
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
931bdec4ed765bad3d3a7eb915e6dfb9
  adjustBy1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "adjustBy"#) -}
cdef4ea33b31c9ec91ade277fd67181e
  alterBy ::
    (Data.ByteString.Internal.ByteString
     -> a -> GHC.Base.Maybe a -> GHC.Base.Maybe a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3,
     Strictness: <L,C(C1(C1(U)))><S(LLLS),1*U(U,U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.ByteString.Internal.ByteString
                         -> a -> GHC.Base.Maybe a -> GHC.Base.Maybe a)
                   (w1 :: Data.ByteString.Internal.ByteString)
                   (w2 :: a) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.BigEndianPatricia.Internal.$walterBy
                   @ a
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
b7364dc4286bc2fcb9186c308d3cf1da
  alterBy_ ::
    (Data.ByteString.Internal.ByteString
     -> a
     -> GHC.Base.Maybe a
     -> Data.Trie.BigEndianPatricia.Internal.Trie a
     -> (GHC.Base.Maybe a, Data.Trie.BigEndianPatricia.Internal.Trie a))
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><S(LLLS),1*U(U,U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.ByteString.Internal.ByteString
                         -> a
                         -> GHC.Base.Maybe a
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> (GHC.Base.Maybe a, Data.Trie.BigEndianPatricia.Internal.Trie a))
                   (w1 :: Data.ByteString.Internal.ByteString)
                   (w2 :: a) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.BigEndianPatricia.Internal.$walterBy_
                   @ a
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
2de4a62f9f6cfd3f943cece776f9a4a2
  arc ::
    Data.ByteString.Internal.ByteString
    -> GHC.Base.Maybe a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3, Strictness: <L,1*U(U,U,U,U)><S,1*U><S,1*U>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   (k :: Data.ByteString.Internal.ByteString)
                   (mv :: GHC.Base.Maybe a)
                   (t :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 case mv of wild {
                   GHC.Base.Nothing
                   -> case t of wild1 {
                        Data.Trie.BigEndianPatricia.Internal.Empty
                        -> Data.Trie.BigEndianPatricia.Internal.Empty @ a
                        Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 mv' t'
                        -> case Data.ByteString.Internal.$fMonoidByteString_$cmappend
                                  k
                                  (Data.ByteString.Internal.PS
                                     dt
                                     dt1
                                     dt2
                                     dt3) of dt4 { Data.ByteString.Internal.PS dt5 dt6 dt7 dt8 ->
                           Data.Trie.BigEndianPatricia.Internal.Arc
                             @ a
                             dt5
                             dt6
                             dt7
                             dt8
                             mv'
                             t' }
                        Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 ds ds1
                        -> case k of wild2 { Data.ByteString.Internal.PS dt2 dt3 dt4 dt5 ->
                           let {
                             l :: GHC.Types.Int = GHC.Types.I# dt5
                           } in
                           case GHC.Base.$
                                  @ 'GHC.Types.PtrRepLifted
                                  @ GHC.Types.Bool
                                  @ GHC.Types.Bool
                                  (GHC.Base.assert
                                     @ GHC.Types.Bool
                                     (GHC.Classes.geInt l (GHC.Types.I# 0#)))
                                  (GHC.Classes.leInt l (GHC.Types.I# 0#)) of wild3 {
                             GHC.Types.False
                             -> Data.Trie.BigEndianPatricia.Internal.Arc
                                  @ a
                                  dt2
                                  dt3
                                  dt4
                                  dt5
                                  (GHC.Base.Nothing @ a)
                                  wild1
                             GHC.Types.True -> wild1 } } }
                   GHC.Base.Just ds
                   -> case k of dt { Data.ByteString.Internal.PS dt1 dt2 dt3 dt4 ->
                      case t of dt5 { DEFAULT ->
                      Data.Trie.BigEndianPatricia.Internal.Arc
                        @ a
                        dt1
                        dt2
                        dt3
                        dt4
                        wild
                        dt5 } } }) -}
d306762e0ed80e210323e3a2cd5af14e
  contextualFilterMap ::
    (a
     -> Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Base.Maybe b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U> -}
dc8a4a9532b285bc65db9f5ba8a7078d
  contextualMap ::
    (a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Trie.BigEndianPatricia.Internal.Trie b
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> Data.Trie.BigEndianPatricia.Internal.Empty @ b
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing
                            -> case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Nothing @ b)
                                 dt4 }
                            GHC.Base.Just v
                            -> case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Just @ b (f v t))
                                 dt4 } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> case go l of dt2 { DEFAULT ->
                          case go r of dt3 { DEFAULT ->
                          Data.Trie.BigEndianPatricia.Internal.Branch
                            @ b
                            dt
                            dt1
                            dt2
                            dt3 } } }
                 } in
                 go eta) -}
49b381bf2ae11f74ab58cba79f4b19ea
  contextualMap' ::
    (a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.Trie.BigEndianPatricia.Internal.Trie a
                         -> Data.Trie.BigEndianPatricia.Internal.Trie b
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty
                       -> Data.Trie.BigEndianPatricia.Internal.Empty @ b
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 ds1 t
                       -> case ds1 of wild1 {
                            GHC.Base.Nothing
                            -> case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Nothing @ b)
                                 dt4 }
                            GHC.Base.Just v
                            -> case f v t of x1 { DEFAULT ->
                               case go t of dt4 { DEFAULT ->
                               Data.Trie.BigEndianPatricia.Internal.Arc
                                 @ b
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 (GHC.Base.Just @ b x1)
                                 dt4 } } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> case go l of dt2 { DEFAULT ->
                          case go r of dt3 { DEFAULT ->
                          Data.Trie.BigEndianPatricia.Internal.Branch
                            @ b
                            dt
                            dt1
                            dt2
                            dt3 } } }
                 } in
                 go eta) -}
b0d89e4c6a6c87ae9599274783e58761
  contextualMapBy ::
    (Data.ByteString.Internal.ByteString
     -> a
     -> Data.Trie.BigEndianPatricia.Internal.Trie a
     -> GHC.Base.Maybe b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <L,C(C1(C1(U)))><S,1*U> -}
e863dc1f9e20e69577cf90d86008ae34
  empty :: Data.Trie.BigEndianPatricia.Internal.Trie a
  {- HasNoCafRefs, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Trie.BigEndianPatricia.Internal.Empty -}
f9d47971cb7472c87fcdca50641ec8a8
  errorLogHead ::
    GHC.Base.String
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.ByteStringInternal.ByteStringElem
  {- Arity: 2, Strictness: <L,1*U><S(SLSS),1*U(U,U,U,U)>m,
     Inline: NOINLINE -}
8a40ae402420b8f62147afb6918022f3
  filterMap ::
    (a -> GHC.Base.Maybe b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <L,C(U)><S,1*U> -}
a9cdd0b44d88c10f0755fad281dbeb54
  foldrWithKey ::
    (Data.ByteString.Internal.ByteString -> a -> b -> b)
    -> b -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
  {- Arity: 3, Strictness: <L,C(C1(C1(U)))><L,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (fcons :: Data.ByteString.Internal.ByteString -> a -> b -> b)
                   (nil :: b)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.ByteString.Internal.ByteString
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b -> b
                     {- Arity: 3, Strictness: <L,U(U,U,U,U)><S,1*U><L,1*U> -}
                   = \ (ds :: Data.ByteString.Internal.ByteString)
                       (ds1 :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                       (eta1 :: b) ->
                     case ds1 of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> eta1
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 mv t
                       -> let {
                            k' :: Data.ByteString.Internal.ByteString
                            = case ds of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                              Data.ByteString.Internal.$w$c<> ww1 ww2 ww3 ww4 dt dt1 dt2 dt3 }
                          } in
                          case mv of wild1 {
                            GHC.Base.Nothing -> go k' t eta1
                            GHC.Base.Just v -> fcons k' v (go k' t eta1) }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 l r
                       -> go ds l (go ds r eta1) }
                 } in
                 go Data.ByteString.empty eta nil) -}
45c240b0eaf31a2b8f585adec851ee1d
  lookupBy_ ::
    (GHC.Base.Maybe a
     -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
    -> b
    -> (Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> b
  {- Arity: 5,
     Strictness: <L,C(C1(U))><L,U><L,C(U)><L,U(U,U,U,U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: GHC.Base.Maybe a
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
                   (z :: b)
                   (a1 :: Data.Trie.BigEndianPatricia.Internal.Trie a -> b)
                   (eta :: Data.ByteString.Internal.ByteString)
                   (eta1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 letrec {
                   go :: Data.ByteString.Internal.ByteString
                         -> Data.Trie.BigEndianPatricia.Internal.Trie a -> b
                     {- Arity: 2, Strictness: <L,U(U,U,U,U)><S,1*U> -}
                   = \ (ds :: Data.ByteString.Internal.ByteString)
                       (ds1 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                     case ds1 of wild {
                       Data.Trie.BigEndianPatricia.Internal.Empty -> z
                       Data.Trie.BigEndianPatricia.Internal.Arc dt dt1 dt2 dt3 mv t
                       -> case ds of ww5 { Data.ByteString.Internal.PS ww6 ww7 ww8 ww9 ->
                          case Data.Trie.ByteStringInternal.$wbreakMaximalPrefix
                                 dt
                                 dt1
                                 dt2
                                 dt3
                                 ww6
                                 ww7
                                 ww8
                                 ww9 of wild1 { (,,) ds2 k' q' ->
                          case k' of wild2 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<=# dt7 0#) of wild3 {
                            GHC.Types.False
                            -> case q' of wild4 { Data.ByteString.Internal.PS dt8 dt9 dt10 dt11 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<=# dt11 0#) of wild5 {
                                 GHC.Types.False -> z
                                 GHC.Types.True
                                 -> a1
                                      (Data.Trie.BigEndianPatricia.Internal.Arc
                                         @ a
                                         dt4
                                         dt5
                                         dt6
                                         dt7
                                         mv
                                         t) } }
                            GHC.Types.True
                            -> case q' of wild4 { Data.ByteString.Internal.PS dt8 dt9 dt10 dt11 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<=# dt11 0#) of wild5 {
                                 GHC.Types.False -> go wild4 t GHC.Types.True -> f mv t } } } } } }
                       Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 ds2 ds3
                       -> let {
                            qh :: Data.Trie.ByteStringInternal.ByteStringElem
                            = Data.Trie.BigEndianPatricia.Internal.errorLogHead
                                Data.Trie.BigEndianPatricia.Internal.lookupBy_1
                                ds
                          } in
                          letrec {
                            findArc :: Data.Trie.BigEndianPatricia.Internal.Trie a -> b
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds4 :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                              case ds4 of wild1 {
                                Data.Trie.BigEndianPatricia.Internal.Empty -> z
                                Data.Trie.BigEndianPatricia.Internal.Arc dt2 dt3 dt4 dt5 ds5 ds6
                                -> go ds wild1
                                Data.Trie.BigEndianPatricia.Internal.Branch dt2 dt3 l r
                                -> case qh of wild2 { GHC.Word.W8# x# ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.neWord#
                                             (GHC.Prim.narrow8Word#
                                                (GHC.Prim.and#
                                                   x#
                                                   (GHC.Prim.xor#
                                                      (GHC.Prim.xor#
                                                         (GHC.Prim.minusWord# dt3 1##)
                                                         18446744073709551615##)
                                                      dt3)))
                                             dt2) of wild3 {
                                     GHC.Types.False
                                     -> case GHC.Prim.and# x# dt3 of wild4 {
                                          DEFAULT -> findArc r 0## -> findArc l }
                                     GHC.Types.True -> z } } }
                          } in
                          findArc wild }
                 } in
                 case eta1 of wild {
                   DEFAULT -> go eta wild
                   Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 ds ds1
                   -> case eta of wild1 { Data.ByteString.Internal.PS dt2 dt3 dt4 dt5 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# dt5 0#) of wild2 {
                        GHC.Types.False -> go wild1 wild
                        GHC.Types.True -> f (GHC.Base.Nothing @ a) wild } } }) -}
c51114a0c55700b99d67bb9c74646413
  lookupBy_1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "lookupBy_"#) -}
bcc77b33988824b21bc87f17e5554a14
  mapBy ::
    (Data.ByteString.Internal.ByteString -> a -> GHC.Base.Maybe b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie b
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U> -}
4346bcd78a1ae16dd35a129092b138ac
  matchFB_ ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.ByteString.Internal.ByteString
    -> (GHC.Types.Int -> a -> r -> r)
    -> r
    -> r
  {- Arity: 4,
     Strictness: <S,1*U><L,U(U,U,U,U)><L,C(C1(C1(U)))><L,1*U> -}
b33b574b941c14759f12dcd8c130c774
  match_ ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.ByteString.Internal.ByteString
    -> GHC.Base.Maybe (GHC.Types.Int, a)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U,U)>,
     Unfolding: (\ @ a
                   (x :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (y :: Data.ByteString.Internal.ByteString) ->
                 case x of wild {
                   DEFAULT
                   -> Data.Trie.BigEndianPatricia.Internal.match__goNothing
                        @ a
                        @ a
                        Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie6
                        y
                        wild
                   Data.Trie.BigEndianPatricia.Internal.Branch dt dt1 ds ds1
                   -> case y of wild1 { Data.ByteString.Internal.PS dt2 dt3 dt4 dt5 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# dt5 0#) of wild2 {
                        GHC.Types.False
                        -> Data.Trie.BigEndianPatricia.Internal.match__goNothing
                             @ a
                             @ a
                             Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie6
                             wild1
                             wild
                        GHC.Types.True -> GHC.Base.Nothing @ (GHC.Types.Int, a) } } }) -}
c9ecbbbb6ec12fe95367cefb0e9f5427
  match__goNothing ::
    GHC.Types.Int
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.BigEndianPatricia.Internal.Trie t
    -> GHC.Base.Maybe (GHC.Types.Int, t)
  {- Arity: 3, Strictness: <L,U(U)><L,U(U,U,U,U)><S,1*U> -}
0be1cca8e42612aa04d0c0753cceefe6
  matches_ ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.ByteString.Internal.ByteString -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (t :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (q :: Data.ByteString.Internal.ByteString) ->
                 GHC.Base.build
                   @ (GHC.Types.Int, a)
                   (\ @ b
                      (cons :: (GHC.Types.Int, a) -> b -> b)[OneShot]
                      (nil :: b)[OneShot] ->
                    Data.Trie.BigEndianPatricia.Internal.matchFB_
                      @ a
                      @ b
                      t
                      q
                      (\ (x :: GHC.Types.Int) (x1 :: a)[OneShot] -> cons (x, x1))
                      nil)) -}
d8681f760e32fb3f50e491ad8c194e2b
  maxAssoc ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe (Data.ByteString.Internal.ByteString, a)
  {- Arity: 1,
     Unfolding: (\ @ a ->
                 Data.Trie.BigEndianPatricia.Internal.maxAssoc_go
                   @ a
                   Data.ByteString.empty) -}
e830563fa07ac51130a1b8ca4c58c2c8
  maxAssoc_go ::
    Data.ByteString.Internal.ByteString
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe (Data.ByteString.Internal.ByteString, a)
  {- Arity: 2, Strictness: <L,1*U(U,U,U,U)><S,1*U> -}
a9cdd0b44d88c10f0755fad281dbeb54
  mergeBy ::
    (a -> a -> GHC.Base.Maybe a)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,U> -}
b9f28169d205816444994ca02806ab91
  minAssoc ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe (Data.ByteString.Internal.ByteString, a)
  {- Arity: 1,
     Unfolding: (\ @ a ->
                 Data.Trie.BigEndianPatricia.Internal.minAssoc_go
                   @ a
                   Data.ByteString.empty) -}
a7727cf7397af404856d81667a04f74b
  minAssoc_go ::
    Data.ByteString.Internal.ByteString
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe (Data.ByteString.Internal.ByteString, a)
  {- Arity: 2, Strictness: <L,1*U(U,U,U,U)><S,1*U> -}
a81de30a53606e742c6102fdca292c0c
  null ::
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (ds :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Data.Trie.BigEndianPatricia.Internal.Empty -> GHC.Types.True }) -}
bed59658c8458c69355cdb3f4faf3fc9
  showTrie ::
    GHC.Show.Show a =>
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U> -}
a9cdd0b44d88c10f0755fad281dbeb54
  singleton ::
    Data.ByteString.Internal.ByteString
    -> a -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLSS),1*U(U,U,U,U)><L,U>m2,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a (k :: Data.ByteString.Internal.ByteString) (v :: a) ->
                 case k of dt { Data.ByteString.Internal.PS dt1 dt2 dt3 dt4 ->
                 Data.Trie.BigEndianPatricia.Internal.Arc
                   @ a
                   dt1
                   dt2
                   dt3
                   dt4
                   (GHC.Base.Just @ a v)
                   (Data.Trie.BigEndianPatricia.Internal.Empty @ a) }) -}
4c30b28fdde7bc8838842550a9dfe794
  size ::
    Data.Trie.BigEndianPatricia.Internal.Trie a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.size'
                   @ a
                   t
                   (GHC.Base.id @ GHC.Types.Int)
                   (GHC.Types.I# 0#)) -}
81feefb68067be9e605feba04613011e
  size' ::
    Data.Trie.BigEndianPatricia.Internal.Trie a
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><C(S),1*C1(U(U))><L,U(U)> -}
9c28f663f184c92f34e4fe19709f0fb0
  submap ::
    Data.ByteString.Internal.ByteString
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
  {- Arity: 2, Strictness: <L,U(U,U,U,U)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (q :: Data.ByteString.Internal.ByteString)
                   (eta :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 Data.Trie.BigEndianPatricia.Internal.lookupBy_
                   @ a
                   @ (Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (Data.Trie.BigEndianPatricia.Internal.arc @ a q)
                   (Data.Trie.BigEndianPatricia.Internal.Empty @ a)
                   (Data.Trie.BigEndianPatricia.Internal.arc
                      @ a
                      q
                      (GHC.Base.Nothing @ a))
                   q
                   eta) -}
0e0a6c356846e37c886eb756ca4f4bf9
  toListBy ::
    (Data.ByteString.Internal.ByteString -> a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a -> [b]
  {- Arity: 2, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Data.ByteString.Internal.ByteString -> a -> b)
                   (t :: Data.Trie.BigEndianPatricia.Internal.Trie a) ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 ->
                    Data.Trie.BigEndianPatricia.Internal.toListByFB
                      @ a
                      @ b
                      @ b1
                      f
                      t)) -}
5be244bb8f6597f565cefae1050bdb01
  toListByFB ::
    (Data.ByteString.Internal.ByteString -> a -> b)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> (b -> c -> c)
    -> c
    -> c
  {- Arity: 4, Strictness: <L,C(U)><S,1*U><L,C(C1(U))><L,1*U>,
     Inline: INLINE[0] (sat-args=4),
     Unfolding: InlineRule (4, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.ByteString.Internal.ByteString -> a -> b)
                   (t :: Data.Trie.BigEndianPatricia.Internal.Trie a)
                   (cons :: b -> c -> c)
                   (nil :: c) ->
                 Data.Trie.BigEndianPatricia.Internal.foldrWithKey
                   @ a
                   @ c
                   (\ (x :: Data.ByteString.Internal.ByteString) (x1 :: a)[OneShot] ->
                    cons (f x x1))
                   nil
                   t) -}
1c94d6efb0f27f9880f23cf5ad694640
  updateMaxViewBy ::
    (Data.ByteString.Internal.ByteString -> a -> GHC.Base.Maybe a)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe
         (Data.ByteString.Internal.ByteString, a,
          Data.Trie.BigEndianPatricia.Internal.Trie a)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U> -}
d6cb24a43cd13695105a906aba30c9e9
  updateMinViewBy ::
    (Data.ByteString.Internal.ByteString -> a -> GHC.Base.Maybe a)
    -> Data.Trie.BigEndianPatricia.Internal.Trie a
    -> GHC.Base.Maybe
         (Data.ByteString.Internal.ByteString, a,
          Data.Trie.BigEndianPatricia.Internal.Trie a)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U> -}
instance GHC.Base.Applicative [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fApplicativeTrie
instance Data.Binary.Class.Binary [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fBinaryTrie
instance GHC.Classes.Eq [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fEqTrie
instance Data.Foldable.Foldable [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fFoldableTrie
instance GHC.Base.Functor [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fFunctorTrie
instance GHC.Base.Monad [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fMonadTrie
instance GHC.Base.Monoid [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fMonoidTrie
instance Data.Semigroup.Semigroup [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fSemigroupTrie
instance GHC.Show.Show [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fShowTrie
instance Data.Traversable.Traversable [Data.Trie.BigEndianPatricia.Internal.Trie]
  = Data.Trie.BigEndianPatricia.Internal.$fTraversableTrie
"SPEC/Data.Trie.BigEndianPatricia.Internal $dmfail @ Trie" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                         Data.Trie.BigEndianPatricia.Internal.Trie)
  GHC.Base.$dmfail @ Data.Trie.BigEndianPatricia.Internal.Trie
                   $dMonad
  = Data.Trie.BigEndianPatricia.Internal.$fMonadTrie_$s$dmfail
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

