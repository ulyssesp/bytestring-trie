
==================== FINAL INTERFACE ====================
2018-07-20 18:06:41.0141443 UTC

interface bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX:Data.Trie.ArrayMapped.SparseArray 8001
  interface hash: 49cb3b65a63fc1226bbec7432b5733b1
  ABI hash: d03e14eb354c4dab7a5cd4b32a5f4d5a
  export-list hash: cf846ce28b31bf9094791820cdefe9f4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4ab95462ab5182045141f084fc0e374a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Trie.ArrayMapped.SparseArray.adjust
  Data.Trie.ArrayMapped.SparseArray.adjust'
  Data.Trie.ArrayMapped.SparseArray.adjustK
  Data.Trie.ArrayMapped.SparseArray.adjustK'
  Data.Trie.ArrayMapped.SparseArray.assocs
  Data.Trie.ArrayMapped.SparseArray.assocsBy
  Data.Trie.ArrayMapped.SparseArray.delete
  Data.Trie.ArrayMapped.SparseArray.differenceL
  Data.Trie.ArrayMapped.SparseArray.differenceR
  Data.Trie.ArrayMapped.SparseArray.doubleton
  Data.Trie.ArrayMapped.SparseArray.elems
  Data.Trie.ArrayMapped.SparseArray.empty
  Data.Trie.ArrayMapped.SparseArray.filter
  Data.Trie.ArrayMapped.SparseArray.filterMap
  Data.Trie.ArrayMapped.SparseArray.filterMapWithKey
  Data.Trie.ArrayMapped.SparseArray.filterWithKey
  Data.Trie.ArrayMapped.SparseArray.foldL
  Data.Trie.ArrayMapped.SparseArray.foldR
  Data.Trie.ArrayMapped.SparseArray.foldlWithKey
  Data.Trie.ArrayMapped.SparseArray.foldlWithKey'
  Data.Trie.ArrayMapped.SparseArray.foldrWithKey
  Data.Trie.ArrayMapped.SparseArray.foldrWithKey'
  Data.Trie.ArrayMapped.SparseArray.fromList
  Data.Trie.ArrayMapped.SparseArray.insert
  Data.Trie.ArrayMapped.SparseArray.insert'
  Data.Trie.ArrayMapped.SparseArray.intersectionL
  Data.Trie.ArrayMapped.SparseArray.intersectionR
  Data.Trie.ArrayMapped.SparseArray.intersectionWith
  Data.Trie.ArrayMapped.SparseArray.intersectionWith'
  Data.Trie.ArrayMapped.SparseArray.isSubarrayOf
  Data.Trie.ArrayMapped.SparseArray.keys
  Data.Trie.ArrayMapped.SparseArray.length
  Data.Trie.ArrayMapped.SparseArray.lookup
  Data.Trie.ArrayMapped.SparseArray.map
  Data.Trie.ArrayMapped.SparseArray.map'
  Data.Trie.ArrayMapped.SparseArray.mapWithKey
  Data.Trie.ArrayMapped.SparseArray.mapWithKey'
  Data.Trie.ArrayMapped.SparseArray.member
  Data.Trie.ArrayMapped.SparseArray.notMember
  Data.Trie.ArrayMapped.SparseArray.null
  Data.Trie.ArrayMapped.SparseArray.partition
  Data.Trie.ArrayMapped.SparseArray.partitionMap
  Data.Trie.ArrayMapped.SparseArray.partitionMapWithKey
  Data.Trie.ArrayMapped.SparseArray.partitionWithKey
  Data.Trie.ArrayMapped.SparseArray.rzip
  Data.Trie.ArrayMapped.SparseArray.rzipFilter
  Data.Trie.ArrayMapped.SparseArray.rzipFilter_
  Data.Trie.ArrayMapped.SparseArray.rzipWith
  Data.Trie.ArrayMapped.SparseArray.rzipWith'
  Data.Trie.ArrayMapped.SparseArray.rzipWith'_
  Data.Trie.ArrayMapped.SparseArray.rzipWithKey
  Data.Trie.ArrayMapped.SparseArray.rzipWithKey'
  Data.Trie.ArrayMapped.SparseArray.rzipWithKey'_
  Data.Trie.ArrayMapped.SparseArray.rzipWithKey_
  Data.Trie.ArrayMapped.SparseArray.rzipWith_
  Data.Trie.ArrayMapped.SparseArray.sequenceST
  Data.Trie.ArrayMapped.SparseArray.singleton
  Data.Trie.ArrayMapped.SparseArray.traverseST
  Data.Trie.ArrayMapped.SparseArray.unionFilterWith
  Data.Trie.ArrayMapped.SparseArray.unionFilterWith_
  Data.Trie.ArrayMapped.SparseArray.unionL
  Data.Trie.ArrayMapped.SparseArray.unionR
  Data.Trie.ArrayMapped.SparseArray.unionWith
  Data.Trie.ArrayMapped.SparseArray.unionWith'
  Data.Trie.ArrayMapped.SparseArray.unionWith'_
  Data.Trie.ArrayMapped.SparseArray.unionWith_
  Data.Trie.ArrayMapped.SparseArray.viewSubsingleton
  Data.Trie.ArrayMapped.SparseArray.Key
  Data.Trie.ArrayMapped.SparseArray.SparseArray
  Data.Trie.ArrayMapped.SparseArray.SubsingletonView{Data.Trie.ArrayMapped.SparseArray.IsEmpty Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton Data.Trie.ArrayMapped.SparseArray.IsSingleton}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      data-or-1.0.0.5@data-or-1.0.0.5-7fP9a913JBX6EaOUN88kxz
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Control.Monad.ST 5bfaae5dac94ed9df935d3d24117e9c2
import  -/  base-4.9.0.0:Data.Bits c954f6297e2203ba924b7d4bb91aa2cf
import  -/  base-4.9.0.0:Data.Coerce c21102d3a648c4411793164222c24920
import  -/  base-4.9.0.0:Data.Either 4cef602ce360a0155ac0dd580a5b4863
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Functor 67cebb006c069ea73adcd2d468cdb0dc
import  -/  base-4.9.0.0:Data.Traversable 578f976513fd28b7f58c156ea20c192a
import  -/  base-4.9.0.0:Foreign.C 936ad315e3218891f8ed65ae1b944927
import  -/  base-4.9.0.0:Foreign.C.Types a8dbaaa1204b77d62f4d101020d1db96
import  -/  base-4.9.0.0:Foreign.Storable 95717af526f1aa9266bec9a33467111a
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.0.0:GHC.Exts 8dde1ef8f2283d1c13b06a4e51aded72
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.ST 27b52e9f9ef817e2a3a4182e8c143d4d
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary 6874ec1640b9c9e26e0b523287f2c847
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Class 8597f8b1c2ab4e12727292e0fd7fcc19
import  -/  data-or-1.0.0.5@data-or-1.0.0.5-7fP9a913JBX6EaOUN88kxz:Data.Or 3dfdf9cfc53cee2824c417ee646cdd9c
import  -/  deepseq-1.4.2.0@deepseq-1.4.2.0:Control.DeepSeq 7523df5398c1a772ea4aefea3d519d92
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
addDependentFile "C:\Users\ulyssesp\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.1\lib\include\ghcversion.h"
addDependentFile ".stack-work\dist\b7fec021\build\autogen\cabal_macros.h"
c48038d4f7bb9c300e9cddc90e0c39f8
  $fBinarySparseArray ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Class.Binary
      (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(U(A,U)),U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dBinary :: Data.Binary.Class.Binary a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                  (Data.Trie.ArrayMapped.SparseArray.$fBinarySparseArray_$cput
                     @ a
                     $dBinary)
                  (Data.Trie.ArrayMapped.SparseArray.$fBinarySparseArray_$cget
                     @ a
                     $dBinary)
                  (Data.Trie.ArrayMapped.SparseArray.$fBinarySparseArray_$cputList
                     @ a
                     $dBinary) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fBinarySparseArray1 ::
    Data.Binary.Class.Binary a =>
    forall r.
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success
         (Data.Trie.ArrayMapped.SparseArray.SparseArray a) r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3,
     Strictness: <L,U(A,U,A)><S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   @ r
                   (w1 :: Data.ByteString.Internal.ByteString)
                   (w2 :: Data.Binary.Get.Internal.Success
                            (Data.Trie.ArrayMapped.SparseArray.SparseArray a) r) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cget
                   @ a
                   w
                   @ r
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fBinarySparseArray_$cget ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get
      (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 3,
     Strictness: <L,U(A,U,A)><S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.ArrayMapped.SparseArray.$fBinarySparseArray1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Binary.Class.Binary a>_R
                 ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                               <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fBinarySparseArray_$cput ::
    Data.Binary.Class.Binary a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Binary.Put.Put
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(U(A,U)),A,A)><S(LS),1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case Data.Trie.ArrayMapped.SparseArray.$w$cput
                        @ a
                        w
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fBinarySparseArray_$cputList ::
    Data.Binary.Class.Binary a =>
    [Data.Trie.ArrayMapped.SparseArray.SparseArray a]
    -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(A,U)),U,A)> -}
91d6579b53eb5d8e3c962c84e9acfa53
  $fEqDynamicSA ::
    GHC.Classes.Eq (Data.Trie.ArrayMapped.SparseArray.DynamicSA s e)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s @ e.
                  @ (Data.Trie.ArrayMapped.SparseArray.DynamicSA s e)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqDynamicSA_$c== @ s @ e)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqDynamicSA_$c/= @ s @ e) -}
91d6579b53eb5d8e3c962c84e9acfa53
  $fEqDynamicSA_$c/= ::
    Data.Trie.ArrayMapped.SparseArray.DynamicSA s e
    -> Data.Trie.ArrayMapped.SparseArray.DynamicSA s e
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ e
                   (x :: Data.Trie.ArrayMapped.SparseArray.DynamicSA s e)
                   (y :: Data.Trie.ArrayMapped.SparseArray.DynamicSA s e) ->
                 GHC.Classes.not
                   (Data.Trie.ArrayMapped.SparseArray.$fEqDynamicSA_$c==
                      @ s
                      @ e
                      x
                      y)) -}
91d6579b53eb5d8e3c962c84e9acfa53
  $fEqDynamicSA_$c== ::
    Data.Trie.ArrayMapped.SparseArray.DynamicSA s e
    -> Data.Trie.ArrayMapped.SparseArray.DynamicSA s e
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLS),1*U(A,A,A,A,U)><S(LLLLS),1*U(A,A,A,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ s
                   @ e
                   (ds :: Data.Trie.ArrayMapped.SparseArray.DynamicSA s e)
                   (ds1 :: Data.Trie.ArrayMapped.SparseArray.DynamicSA s e) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.DSA dt dt1 dt2 dt3 xs ->
                 case ds1 of wild1 { Data.Trie.ArrayMapped.SparseArray.DSA dt4 dt5 dt6 dt7 ys ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.sameMutableArray# @ s @ e xs ys) } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fEqSparseArray ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqSparseArray_$c== @ a $dEq)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqSparseArray_$c/=
                     @ a
                     $dEq) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fEqSparseArray_$c/= ::
    GHC.Classes.Eq a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 GHC.Classes.not
                   (Data.Trie.ArrayMapped.SparseArray.$fEqSparseArray_$c==
                      @ a
                      $dEq
                      x
                      y)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fEqSparseArray_$c== ::
    GHC.Classes.Eq a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w2 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$c==
                   @ a
                   w
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fEqSubsingletonView ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq
      (Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqSubsingletonView_$c==
                     @ a
                     $dEq)
                  (Data.Trie.ArrayMapped.SparseArray.$fEqSubsingletonView_$c/=
                     @ a
                     $dEq) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fEqSubsingletonView_$c/= ::
    GHC.Classes.Eq a =>
    Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
                   (b :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a) ->
                 case a1 of wild {
                   Data.Trie.ArrayMapped.SparseArray.IsEmpty
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Trie.ArrayMapped.SparseArray.IsEmpty -> GHC.Types.False }
                   Data.Trie.ArrayMapped.SparseArray.IsSingleton dt a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Trie.ArrayMapped.SparseArray.IsSingleton dt1 b2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.eqWord# dt dt1) of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case GHC.Classes.== @ a $dEq a2 b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True -> GHC.Types.False } } }
                   Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton
                        -> GHC.Types.False } }) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fEqSubsingletonView_$c== ::
    GHC.Classes.Eq a =>
    Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
                   (ds1 :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a) ->
                 case ds of wild {
                   Data.Trie.ArrayMapped.SparseArray.IsEmpty
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Trie.ArrayMapped.SparseArray.IsEmpty -> GHC.Types.True }
                   Data.Trie.ArrayMapped.SparseArray.IsSingleton dt a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Trie.ArrayMapped.SparseArray.IsSingleton dt1 b2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.eqWord# dt dt1) of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ a $dEq a2 b2 } }
                   Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton
                        -> GHC.Types.True } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray ::
    Data.Foldable.Foldable
      Data.Trie.ArrayMapped.SparseArray.SparseArray
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.ArrayMapped.SparseArray.SparseArray
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfold
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldMap
                  Data.Trie.ArrayMapped.SparseArray.elems_$cfoldr
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldr'
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldl
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldl'
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldr1
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldl1
                  Data.Trie.ArrayMapped.SparseArray.elems
                  Data.Trie.ArrayMapped.SparseArray.__null
                  Data.Trie.ArrayMapped.SparseArray.__length
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$celem
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cmaximum
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cminimum
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$csum
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cproduct -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray1 ::
    GHC.Num.Num a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(A,A,1*U,A,A,A,1*C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cproduct @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray2 ::
    GHC.Num.Num a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(1*U,A,A,A,A,A,1*C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$csum @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$celem ::
    GHC.Classes.Eq a =>
    a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 (\ (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                  case eta1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                  letrec {
                    go :: GHC.Prim.Array# a
                          -> GHC.Types.Int -> Data.Monoid.Any -> Data.Monoid.Any
                      {- Arity: 3 -}
                    = \ (xs :: GHC.Prim.Array# a)
                        (n :: GHC.Types.Int)
                        (z :: Data.Monoid.Any) ->
                      case n of n1 { GHC.Types.I# ipv ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ipv 0#) of wild {
                        GHC.Types.False -> z
                        GHC.Types.True
                        -> case case f (case GHC.Prim.indexArray#
                                               @ a
                                               xs
                                               ipv of ds { Unit# ipv1 ->
                                        ipv1 }) of wild1 {
                                  GHC.Types.False -> z `cast` (Data.Monoid.N:Any[0])
                                  GHC.Types.True -> GHC.Types.True } of nt { DEFAULT ->
                           go
                             xs
                             (GHC.Types.I# (GHC.Prim.-# ipv 1#))
                             nt `cast` (Sym (Data.Monoid.N:Any[0])) } } }
                  } in
                  go
                    ww2
                    (GHC.Types.I#
                       (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)) 1#))
                    GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0])) })
                   `cast`
                 (<Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
                  ->_R Data.Monoid.N:Any[0])) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfold ::
    GHC.Base.Monoid m =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),U(1*U,1*C(C1(U)),A)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray m) ->
                 Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldr'
                   @ m
                   @ m
                   (GHC.Base.mappend @ m $dMonoid)
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a -> m) -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLL),U(1*U,1*U,A)><L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray_$cfoldr'
                   @ a
                   @ m
                   (let {
                      f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                    } in
                    \ (x :: a) -> f1 (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldl ::
    (b -> a -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldl
                   @ b
                   @ a
                   w
                   w1
                   ww1
                   ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldl' ::
    (b -> a -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S,1*U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldl'
                   @ b
                   @ a
                   w
                   w1
                   ww1
                   ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldl1 ::
    (a -> a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> a -> a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldl1 @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldr' ::
    (a -> b -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S,1*U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldr'
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cfoldr1 ::
    (a -> a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> a -> a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldr1 @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cmaximum ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cmaximum @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cminimum ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cminimum @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$cproduct ::
    GHC.Num.Num a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(A,A,1*U,A,A,A,1*C1(U))><S(SS),1*U(U,U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFoldableSparseArray_$csum ::
    GHC.Num.Num a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(1*U,A,A,A,A,A,1*C1(U))><S(SS),1*U(U,U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFunctorSparseArray ::
    GHC.Base.Functor Data.Trie.ArrayMapped.SparseArray.SparseArray
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.ArrayMapped.SparseArray.SparseArray
                  Data.Trie.ArrayMapped.SparseArray.map
                  Data.Trie.ArrayMapped.SparseArray.$fFunctorSparseArray_$c<$ -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fFunctorSparseArray_$c<$ ::
    a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <L,U><S(SS),1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.map
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fNFDataSparseArray ::
    Control.DeepSeq.NFData a =>
    Control.DeepSeq.NFData
      (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(H)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Data.Trie.ArrayMapped.SparseArray.$fNFDataSparseArray_$crnf
                  `cast`
                (forall (a :: <*>_N).
                 <Control.DeepSeq.NFData a>_R
                 ->_R Sym (Control.DeepSeq.N:NFData[0]
                               <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_N)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fNFDataSparseArray_$crnf ::
    Control.DeepSeq.NFData a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(H)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Control.DeepSeq.NFData a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$crnf @ a w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray ::
    GHC.Classes.Ord a =>
    GHC.Classes.Ord (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dOrd :: GHC.Classes.Ord a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$cp1Ord
                     @ a
                     $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                     @ a
                     $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$c< @ a $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$c<= @ a $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$c> @ a $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$c>= @ a $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$cmax
                     @ a
                     $dOrd)
                  (Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$cmin
                     @ a
                     $dOrd) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$c< ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$c<= ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$c> ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$c>= ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$ccompare ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dOrd1 :: GHC.Classes.Ord
                               (Data.Trie.ArrayMapped.SparseArray.Key, a)
                   = GHC.Classes.$fOrd(,)
                       @ GHC.Word.Word8
                       @ a
                       GHC.Word.$fOrdWord8
                       $dOrd
                 } in
                 \ (sa :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (sa' :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case sa of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 case sa' of wild1 { Data.Trie.ArrayMapped.SparseArray.SA dt1 xs1 ->
                 letrec {
                   $wgo2 :: GHC.Prim.Array# a
                            -> GHC.Prim.Int#
                            -> GHC.Prim.Word#
                            -> GHC.Prim.Word#
                            -> GHC.Prim.Word#
                            -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
                     {- Arity: 5, Strictness: <L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
                   = \ (w :: GHC.Prim.Array# a)
                       (ww :: GHC.Prim.Int#)
                       (ww1 :: GHC.Prim.Word#)
                       (ww2 :: GHC.Prim.Word#)
                       (ww3 :: GHC.Prim.Word#) ->
                     case ww1 of wild2 {
                       DEFAULT
                       -> case GHC.Prim.and# wild2 ww2 of wild3 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ (Data.Trie.ArrayMapped.SparseArray.Key, a)
                                 (GHC.Word.W8# ww3,
                                  case GHC.Prim.indexArray# @ a w ww of ds { Unit# ipv -> ipv })
                                 ($wgo2
                                    w
                                    (GHC.Prim.+# ww 1#)
                                    (GHC.Prim.xor# wild2 ww2)
                                    (GHC.Prim.uncheckedShiftL# ww2 1#)
                                    (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww3 1##)))
                            0##
                            -> $wgo2
                                 w
                                 ww
                                 wild2
                                 (GHC.Prim.uncheckedShiftL# ww2 1#)
                                 (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww3 1##)) }
                       0## -> GHC.Types.[] @ (Data.Trie.ArrayMapped.SparseArray.Key, a) }
                 } in
                 letrec {
                   $wgo3 :: GHC.Prim.Array# a
                            -> GHC.Prim.Int#
                            -> GHC.Prim.Word#
                            -> GHC.Prim.Word#
                            -> GHC.Prim.Word#
                            -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
                     {- Arity: 5, Strictness: <L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
                   = \ (w :: GHC.Prim.Array# a)
                       (ww :: GHC.Prim.Int#)
                       (ww1 :: GHC.Prim.Word#)
                       (ww2 :: GHC.Prim.Word#)
                       (ww3 :: GHC.Prim.Word#) ->
                     case ww1 of wild2 {
                       DEFAULT
                       -> case GHC.Prim.and# wild2 ww2 of wild3 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ (Data.Trie.ArrayMapped.SparseArray.Key, a)
                                 (GHC.Word.W8# ww3,
                                  case GHC.Prim.indexArray# @ a w ww of ds { Unit# ipv -> ipv })
                                 ($wgo3
                                    w
                                    (GHC.Prim.+# ww 1#)
                                    (GHC.Prim.xor# wild2 ww2)
                                    (GHC.Prim.uncheckedShiftL# ww2 1#)
                                    (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww3 1##)))
                            0##
                            -> $wgo3
                                 w
                                 ww
                                 wild2
                                 (GHC.Prim.uncheckedShiftL# ww2 1#)
                                 (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww3 1##)) }
                       0## -> GHC.Types.[] @ (Data.Trie.ArrayMapped.SparseArray.Key, a) }
                 } in
                 GHC.Classes.$fOrd[]_$ccompare
                   @ (Data.Trie.ArrayMapped.SparseArray.Key, a)
                   $dOrd1
                   ($wgo2 xs 0# dt 1## 0##)
                   ($wgo3 xs1 0# dt1 1## 0##) } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$cmax ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$cmin ::
    GHC.Classes.Ord a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (y :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray_$ccompare
                        @ a
                        $dOrd
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fOrdSparseArray_$cp1Ord ::
    GHC.Classes.Ord a =>
    GHC.Classes.Eq (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Data.Trie.ArrayMapped.SparseArray.$fEqSparseArray
                   @ a
                   (GHC.Classes.$p1Ord @ a $dOrd)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fShowSparseArray ::
    GHC.Show.Show a =>
    GHC.Show.Show (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray_$cshowsPrec
                     @ a
                     $dShow)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray_$cshow
                     @ a
                     $dShow)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray_$cshowList
                     @ a
                     $dShow) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fShowSparseArray_$cshow ::
    GHC.Show.Show a =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fShowSparseArray_$cshowList ::
    GHC.Show.Show a =>
    [Data.Trie.ArrayMapped.SparseArray.SparseArray a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Data.Trie.ArrayMapped.SparseArray.SparseArray a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray_$cshowsPrec
                      @ a
                      $dShow
                      GHC.Show.shows22)
                   ls
                   s) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fShowSparseArray_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><L,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cshowsPrec @ a w ww1 w2 }) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fShowSubsingletonView ::
    GHC.Show.Show a =>
    GHC.Show.Show
      (Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView_$cshowsPrec
                     @ a
                     $dShow)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView_$cshow
                     @ a
                     $dShow)
                  (Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView_$cshowList
                     @ a
                     $dShow) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fShowSubsingletonView_$cshow ::
    GHC.Show.Show a =>
    Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a) ->
                 Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fShowSubsingletonView_$cshowList ::
    GHC.Show.Show a =>
    [Data.Trie.ArrayMapped.SparseArray.SubsingletonView a]
    -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Data.Trie.ArrayMapped.SparseArray.SubsingletonView a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Trie.ArrayMapped.SparseArray.SubsingletonView a)
                   (Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView_$cshowsPrec
                      @ a
                      $dShow
                      (GHC.Types.I# 0#))
                   eta
                   eta1) -}
908e4bb8ee25fc4f45b18a0ad6f77fa2
  $fShowSubsingletonView_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
    -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Data.Trie.ArrayMapped.SparseArray.SubsingletonView a) ->
                 case ds1 of wild {
                   Data.Trie.ArrayMapped.SparseArray.IsEmpty
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.CString.unpackCString# "IsEmpty"#)
                   Data.Trie.ArrayMapped.SparseArray.IsSingleton dt b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        f :: [GHC.Types.Char] = GHC.CString.unpackCString# "IsSingleton "#
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow (GHC.Types.I# 11#) b2
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            f
                            (case GHC.Show.$wshowSignedInt
                                    11#
                                    (GHC.Prim.word2Int# dt)
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g x1)) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x1)) } }
                   Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.CString.unpackCString# "IsNotSubsingleton"#) }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fTraversableSparseArray ::
    Data.Traversable.Traversable
      Data.Trie.ArrayMapped.SparseArray.SparseArray
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Trie.ArrayMapped.SparseArray.SparseArray
                  Data.Trie.ArrayMapped.SparseArray.$fFunctorSparseArray
                  Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray
                  Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$ctraverse
                  Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$csequenceA
                  Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$cmapM
                  Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$csequence -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fTraversableSparseArray_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> m (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
  {- Arity: 3,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(U(U,U),1*C1(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S(LS),1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fTraversableSparseArray_$csequence ::
    GHC.Base.Monad m =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray (m a)
    -> m (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 2,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(U(U,U),1*C1(U),C(C1(U)),A,A),A,A,A,A)><S(LS),1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray (m a)) ->
                 Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fTraversableSparseArray_$csequenceA ::
    GHC.Base.Applicative f =>
    Data.Trie.ArrayMapped.SparseArray.SparseArray (f a)
    -> f (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 2, Strictness: <L,U(U(U,U),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray (f a)) ->
                 Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $fTraversableSparseArray_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> f (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
  {- Arity: 3,
     Strictness: <S(S(C(C(S))L)LLLL),U(U(U,U),1*C1(U),C(C1(U)),A,A)><L,C(U)><S(LS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$ctraverse
                   @ f
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2 }) -}
4eb0221e0236221a0f5be228d6f36d25
  $tc'DSA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8599105392836144151##
                   12989951395654162806##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tc'DSA1) -}
624481b1fe3a363b7b7f9cb275a11c70
  $tc'DSA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DSA"#) -}
a613b3a2dc38fb4f67ae9b3c7c96c9e7
  $tc'IsEmpty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10673290982850967553##
                   6738996566742904529##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tc'IsEmpty1) -}
a0bd1049c906cdf76d130bde185b3213
  $tc'IsEmpty1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IsEmpty"#) -}
0266c05d5c777fabe23937e34d40cbf8
  $tc'IsNotSubsingleton :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   321928953856540186##
                   17387686728209944670##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tc'IsNotSubsingleton1) -}
39441e4cc2b364f5797e149dd4023524
  $tc'IsNotSubsingleton1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IsNotSubsingleton"#) -}
017bae07ebab9ff12147f5cb83b347aa
  $tc'IsSingleton :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8957226267355381493##
                   10561113631484588566##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tc'IsSingleton1) -}
99d2caf51bfbaaf8ca64e5d138230385
  $tc'IsSingleton1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IsSingleton"#) -}
2ae2052e760d2e81a0030e1fd112cdbd
  $tc'SA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15855771665744173774##
                   7402986102658856770##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tc'SA1) -}
72781a29fb85fe84fbebe5911af76460
  $tc'SA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SA"#) -}
c70f31d7f0760576eafac2e04cfe6ff7
  $tcDynamicSA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3480462274707557986##
                   1671911150741267609##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tcDynamicSA1) -}
a1aca0a790df3d8ef3afeca5466d9622
  $tcDynamicSA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "DynamicSA"#) -}
8c8ab50f4502fad78a43e4f8cc9617f0
  $tcSparseArray :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1690782027439285990##
                   13841939659900059123##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tcSparseArray1) -}
253bcff2c8f7b9945d1e9e8073eadeb0
  $tcSparseArray1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SparseArray"#) -}
3374329fb8bc361684058e9ec6dab4c8
  $tcSubsingletonView :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3880456251083330385##
                   4838644096878464486##
                   Data.Trie.ArrayMapped.SparseArray.$trModule
                   Data.Trie.ArrayMapped.SparseArray.$tcSubsingletonView1) -}
944576e8fd790fa16d20ad0a066a1c24
  $tcSubsingletonView1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SubsingletonView"#) -}
7c908df5586826616f1cef159925ea23
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Trie.ArrayMapped.SparseArray.$trModule2
                   Data.Trie.ArrayMapped.SparseArray.$trModule1) -}
69877a97ea414b5a8a67aa06752a8449
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Trie.ArrayMapped.SparseArray"#) -}
c0ce720045b7d6ff8877978e675e198b
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX"#) -}
dbe1eb3985874ece19563eae0e255182
  $w$c== ::
    GHC.Classes.Eq a =>
    GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,U><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# a) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> letrec {
                        $weqArray# :: GHC.Prim.Array# a
                                      -> GHC.Prim.Array# a
                                      -> GHC.Prim.Int#
                                      -> GHC.Prim.Int#
                                      -> GHC.Types.Bool
                          {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                        = \ (w1 :: GHC.Prim.Array# a)
                            (w2 :: GHC.Prim.Array# a)
                            (ww4 :: GHC.Prim.Int#)
                            (ww5 :: GHC.Prim.Int#) ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# ww5 ww4) of wild1 {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True
                            -> case GHC.Classes.==
                                      @ a
                                      w
                                      (case GHC.Prim.indexArray# @ a w1 ww5 of ds { Unit# ipv ->
                                       ipv })
                                      (case GHC.Prim.indexArray# @ a w2 ww5 of ds { Unit# ipv ->
                                       ipv }) of wild2 {
                                 GHC.Types.False -> GHC.Types.False
                                 GHC.Types.True -> $weqArray# w1 w2 ww4 (GHC.Prim.+# ww5 1#) } }
                      } in
                      $weqArray#
                        ww1
                        ww3
                        (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww))
                        0# }) -}
ee6f914d3eaf0cfa0672da99220ee6ea
  $w$cfoldl ::
    (b -> a -> b) -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ b
                            @ a
                            (w :: b -> a -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a -> GHC.Types.Int -> b {- Arity: 2 -}
                            = \ (xs :: GHC.Prim.Array# a) (n :: GHC.Types.Int) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ipv 0#) of wild {
                                GHC.Types.False -> w1
                                GHC.Types.True
                                -> w (go xs (GHC.Types.I# (GHC.Prim.-# ipv 1#)))
                                     (case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv1 ->
                                      ipv1 }) } }
                          } in
                          go
                            ww1
                            (GHC.Types.I#
                               (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 1#))) -}
1a74657d6e9713d69a8df664007100f7
  $w$cfoldl' ::
    (b -> a -> b) -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S,1*U><S,U><S,U>, Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ b
                            @ a
                            (w :: b -> a -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a -> GHC.Types.Int -> GHC.Types.Int -> b -> b
                              {- Arity: 4 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (n :: GHC.Types.Int)
                                (i :: GHC.Types.Int)
                                (z :: b) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case i of i1 { GHC.Types.I# ipv1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# ipv1 ipv) of wild {
                                GHC.Types.False -> z
                                GHC.Types.True
                                -> case w z
                                          (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv1 of ds { Unit# ipv2 ->
                                           ipv2 }) of x1 { DEFAULT ->
                                   go xs n1 (GHC.Types.I# (GHC.Prim.+# ipv1 1#)) x1 } } } }
                          } in
                          case w1 of z0 { DEFAULT ->
                          go
                            ww1
                            (GHC.Types.I# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)))
                            (GHC.Types.I# 0#)
                            z0 }) -}
357afe41d222aa670acb10e32120a521
  $w$cfoldl1 ::
    (a -> a -> a) -> GHC.Prim.Word# -> GHC.Prim.Array# a -> a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 letrec {
                   go :: GHC.Prim.Array# a -> GHC.Types.Int -> GHC.Base.Maybe a
                     {- Arity: 2 -}
                   = \ (xs :: GHC.Prim.Array# a) (n :: GHC.Types.Int) ->
                     case n of n1 { GHC.Types.I# ipv ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ipv 0#) of wild {
                       GHC.Types.False -> GHC.Base.Nothing @ a
                       GHC.Types.True
                       -> GHC.Base.Just
                            @ a
                            (case go xs (GHC.Types.I# (GHC.Prim.-# ipv 1#)) of wild1 {
                               GHC.Base.Nothing
                               -> case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv1 ->
                                  ipv1 }
                               GHC.Base.Just x
                               -> w x
                                    (case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv1 ->
                                     ipv1 }) }) } }
                 } in
                 case go
                        ww1
                        (GHC.Types.I#
                           (GHC.Prim.-#
                              (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww))
                              1#)) of wild {
                   GHC.Base.Nothing
                   -> GHC.Err.error
                        @ 'GHC.Types.PtrRepLifted
                        @ a
                        GHC.Err.errorWithoutStackTrace_wild1
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                        (GHC.CString.unpackCString# "foldl1: empty structure"#)
                   GHC.Base.Just v -> v }) -}
08a03f08cc0e1e60f2073d7e614c29a8
  $w$cfoldr ::
    (a -> b -> b) -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            (w :: a -> b -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a -> GHC.Types.Int -> GHC.Types.Int -> b
                              {- Arity: 3 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (n :: GHC.Types.Int)
                                (i :: GHC.Types.Int) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case i of i1 { GHC.Types.I# ipv1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# ipv1 ipv) of wild {
                                GHC.Types.False -> w1
                                GHC.Types.True
                                -> w (case GHC.Prim.indexArray# @ a xs ipv1 of ds { Unit# ipv2 ->
                                      ipv2 })
                                     (go xs n1 (GHC.Types.I# (GHC.Prim.+# ipv1 1#))) } } }
                          } in
                          go
                            ww1
                            (GHC.Types.I# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)))
                            (GHC.Types.I# 0#)) -}
049c649aed5f3e2189feac0909827370
  $w$cfoldr' ::
    (a -> b -> b) -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S,1*U><S,U><S,U>, Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            (w :: a -> b -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a -> GHC.Types.Int -> b -> b {- Arity: 3 -}
                            = \ (xs :: GHC.Prim.Array# a) (n :: GHC.Types.Int) (z :: b) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ipv 0#) of wild {
                                GHC.Types.False -> z
                                GHC.Types.True
                                -> case w (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv of ds { Unit# ipv1 ->
                                           ipv1 })
                                          z of x1 { DEFAULT ->
                                   go xs (GHC.Types.I# (GHC.Prim.-# ipv 1#)) x1 } } }
                          } in
                          case w1 of z0 { DEFAULT ->
                          go
                            ww1
                            (GHC.Types.I#
                               (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 1#))
                            z0 }) -}
b6b624d4fc92dbd23f8dc9bcdeceb27d
  $w$cfoldr1 ::
    (a -> a -> a) -> GHC.Prim.Word# -> GHC.Prim.Array# a -> a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case Data.Trie.ArrayMapped.SparseArray.$w$cfoldr
                        @ a
                        @ (GHC.Base.Maybe a)
                        (\ (x :: a) (m :: GHC.Base.Maybe a)[OneShot] ->
                         GHC.Base.Just
                           @ a
                           (case m of wild {
                              GHC.Base.Nothing -> x GHC.Base.Just y -> w x y }))
                        (GHC.Base.Nothing @ a)
                        ww
                        ww1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Err.error
                        @ 'GHC.Types.PtrRepLifted
                        @ a
                        GHC.Err.errorWithoutStackTrace_wild1
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                        (GHC.CString.unpackCString# "foldr1: empty structure"#)
                   GHC.Base.Just v -> v }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $w$cget ::
    Data.Binary.Class.Binary a =>
    forall r.
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success
         (Data.Trie.ArrayMapped.SparseArray.SparseArray a) r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 6,
     Strictness: <L,U(A,U,A)><S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: Data.Binary.Get.Internal.Success
                            (Data.Trie.ArrayMapped.SparseArray.SparseArray a) r) ->
                 Data.Binary.Class.$w$cget18
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap)[OneShot] ->
                    case a1 of wild { GHC.Types.W# x# ->
                    let {
                      w2 :: Data.Binary.Get.Internal.Get a = Data.Binary.Class.get @ a w
                    } in
                    letrec {
                      $wloop :: GHC.Prim.Int#
                                -> forall r1.
                                   Data.ByteString.Internal.ByteString
                                   -> Data.Binary.Get.Internal.Success [a] r1
                                   -> Data.Binary.Get.Internal.Decoder r1
                        {- Arity: 3, Strictness: <S,U><L,U><L,C(C1(U))>, Inline: [0] -}
                      = \ (ww4 :: GHC.Prim.Int#)
                          @ r1
                          (w3 :: Data.ByteString.Internal.ByteString)
                          (w4 :: Data.Binary.Get.Internal.Success [a] r1) ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# ww4 0#) of wild1 {
                          GHC.Types.False
                          -> let {
                               e :: GHC.Prim.Int# = GHC.Prim.-# ww4 1#
                             } in
                             w2 `cast` (Data.Binary.Get.Internal.N:Get[0] <a>_R)
                               @ r1
                               w3
                               (\ (i'1 :: Data.ByteString.Internal.ByteString) (a2 :: a) ->
                                $wloop
                                  e
                                  @ r1
                                  i'1
                                  (\ (i'2 :: Data.ByteString.Internal.ByteString)[OneShot]
                                     (a3 :: [a])[OneShot] ->
                                   w4 i'2 (GHC.Types.: @ a a2 a3)))
                          GHC.Types.True -> w4 w3 (GHC.Types.[] @ a) }
                    } in
                    $wloop
                      (GHC.Prim.word2Int# (GHC.Prim.popCnt# x#))
                      @ r
                      i'
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: [a])[OneShot] ->
                       w1
                         i'1
                         (Data.Trie.ArrayMapped.SparseArray.$wfromElems @ a x# a2)) })) -}
33bd062b0d1988e371bb8740f463c3bb
  $w$cmaximum ::
    GHC.Classes.Ord a => GHC.Prim.Word# -> GHC.Prim.Array# a -> a
  {- Arity: 3, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 letrec {
                   go :: GHC.Prim.Array# a
                         -> GHC.Types.Int -> Data.Foldable.Max a -> Data.Foldable.Max a
                     {- Arity: 3 -}
                   = \ (xs :: GHC.Prim.Array# a)
                       (n :: GHC.Types.Int)
                       (z :: Data.Foldable.Max a) ->
                     case n of n1 { GHC.Types.I# ipv ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ipv 0#) of wild {
                       GHC.Types.False -> z
                       GHC.Types.True
                       -> let {
                            x :: a
                            = case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv1 -> ipv1 }
                          } in
                          case case z `cast` (Data.Foldable.N:Max[0] <a>_N) of wild1 {
                                 GHC.Base.Nothing -> GHC.Base.Just @ a x
                                 GHC.Base.Just ipv1
                                 -> case GHC.Classes.>= @ a w x ipv1 of wild2 {
                                      GHC.Types.False -> wild1
                                      GHC.Types.True -> GHC.Base.Just @ a x } } of nt { DEFAULT ->
                          go
                            xs
                            (GHC.Types.I# (GHC.Prim.-# ipv 1#))
                            nt `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N) } } }
                 } in
                 case (go
                         ww1
                         (GHC.Types.I#
                            (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 1#))
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N))
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing
                   -> GHC.Err.error
                        @ 'GHC.Types.PtrRepLifted
                        @ a
                        GHC.Err.errorWithoutStackTrace_wild1
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                        (GHC.CString.unpackCString# "maximum: empty structure"#)
                   GHC.Base.Just v -> v }) -}
b92e3f82b5ca7b6a3cce7f5e22f50685
  $w$cminimum ::
    GHC.Classes.Ord a => GHC.Prim.Word# -> GHC.Prim.Array# a -> a
  {- Arity: 3, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 letrec {
                   go :: GHC.Prim.Array# a
                         -> GHC.Types.Int -> Data.Foldable.Min a -> Data.Foldable.Min a
                     {- Arity: 3 -}
                   = \ (xs :: GHC.Prim.Array# a)
                       (n :: GHC.Types.Int)
                       (z :: Data.Foldable.Min a) ->
                     case n of n1 { GHC.Types.I# ipv ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ipv 0#) of wild {
                       GHC.Types.False -> z
                       GHC.Types.True
                       -> let {
                            x :: a
                            = case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv1 -> ipv1 }
                          } in
                          case case z `cast` (Data.Foldable.N:Min[0] <a>_N) of wild1 {
                                 GHC.Base.Nothing -> GHC.Base.Just @ a x
                                 GHC.Base.Just ipv1
                                 -> case GHC.Classes.<= @ a w x ipv1 of wild2 {
                                      GHC.Types.False -> wild1
                                      GHC.Types.True -> GHC.Base.Just @ a x } } of nt { DEFAULT ->
                          go
                            xs
                            (GHC.Types.I# (GHC.Prim.-# ipv 1#))
                            nt `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N) } } }
                 } in
                 case (go
                         ww1
                         (GHC.Types.I#
                            (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 1#))
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N))
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing
                   -> GHC.Err.error
                        @ 'GHC.Types.PtrRepLifted
                        @ a
                        GHC.Err.errorWithoutStackTrace_wild1
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                        (GHC.CString.unpackCString# "minimum: empty structure"#)
                   GHC.Base.Just v -> v }) -}
386fe289ee26572d61cefd5e4c72fc16
  $w$cproduct ::
    GHC.Num.Num a =>
    GHC.Prim.Word# -> GHC.Prim.Array# a -> Data.Monoid.Product a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(A,A,1*U,A,A,A,1*C1(U))><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldr'
                   @ a
                   @ (Data.Monoid.Product a)
                   (let {
                      f :: a -> a -> a = GHC.Num.* @ a w
                    } in
                    (\ (x :: a) -> f x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Product[0] <a>_R)
                     ->_R Sym (Data.Monoid.N:Product[0] <a>_R)))
                   (GHC.Num.fromInteger @ a w Data.Monoid.$fMonoidProduct1)
                     `cast`
                   (Sym (Data.Monoid.N:Product[0] <a>_R))
                   ww
                   ww1) -}
a14e061050512f09f051cb1fa3ba530a
  $w$cput ::
    Data.Binary.Class.Binary a =>
    GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(U(A,U)),A,A)><L,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 let {
                   ds :: Data.Binary.Put.PutM ()
                   = letrec {
                       $wputArray# :: GHC.Prim.Array# a
                                      -> GHC.Prim.Int#
                                      -> GHC.Prim.Int#
                                      -> (# (), Data.ByteString.Builder.Internal.Builder #)
                         {- Arity: 3, Strictness: <L,U><S,U><S,U>, Inline: [0] -}
                       = \ (w1 :: GHC.Prim.Array# a)
                           (ww2 :: GHC.Prim.Int#)
                           (ww3 :: GHC.Prim.Int#) ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# ww3 ww2) of wild {
                           GHC.Types.False
                           -> (# GHC.Tuple.(),
                                 (\ @ r
                                    (cont :: Data.ByteString.Builder.Internal.BuildStep r)
                                    (range :: Data.ByteString.Builder.Internal.BufferRange) ->
                                  cont range)
                                   `cast`
                                 (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)
                           GHC.Types.True
                           -> let {
                                ds1 :: Data.Binary.Put.PutM ()
                                = case $wputArray#
                                         w1
                                         ww2
                                         (GHC.Prim.+# ww3 1#) of ww4 { (#,#) ww5 ww6 ->
                                  (Data.Binary.Put.PairS @ () ww5 ww6)
                                    `cast`
                                  (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }
                              } in
                              (# case ds1
                                        `cast`
                                      (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                                 b1 },
                                 let {
                                   ds2 :: Data.ByteString.Builder.Internal.Builder
                                   = case GHC.Prim.indexArray# @ a w1 ww3 of ds3 { Unit# ipv ->
                                     case (Data.Binary.Class.put @ a w ipv)
                                            `cast`
                                          (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS ds4 w2 ->
                                     w2 } }
                                 } in
                                 (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                                  ds2 `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                    @ r
                                    (case ds1
                                            `cast`
                                          (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                                     w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                       @ r
                                       eta }))
                                   `cast`
                                 (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #) }
                     } in
                     case $wputArray#
                            ww1
                            (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww))
                            0# of ww2 { (#,#) ww3 ww4 ->
                     (Data.Binary.Put.PairS @ () ww3 ww4)
                       `cast`
                     (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }
                 } in
                 (# case ds
                           `cast`
                         (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                    b1 },
                    let {
                      ds1 :: Data.ByteString.Builder.Internal.Builder
                      = case Data.Binary.Class.$w$cput23
                               (GHC.Types.W# ww) of ww2 { (#,#) ww3 ww4 ->
                        ww4 }
                    } in
                    (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     ds1 `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                       @ r
                       (case ds
                               `cast`
                             (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                        w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                          @ r
                          eta }))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
2bd2317419f63253218ea4350ee33e50
  $w$crnf ::
    Control.DeepSeq.NFData a =>
    GHC.Prim.Word# -> GHC.Prim.Array# a -> ()
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(H)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Control.DeepSeq.NFData a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 letrec {
                   $wgo2 :: GHC.Prim.Array# a -> GHC.Prim.Int# -> GHC.Prim.Int# -> ()
                     {- Arity: 3, Strictness: <L,U><S,U><S,U>, Inline: [0] -}
                   = \ (w1 :: GHC.Prim.Array# a)
                       (ww2 :: GHC.Prim.Int#)
                       (ww3 :: GHC.Prim.Int#) ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# ww3 ww2) of wild {
                       GHC.Types.False -> GHC.Tuple.()
                       GHC.Types.True
                       -> case w `cast` (Control.DeepSeq.N:NFData[0] <a>_N)
                                 (case GHC.Prim.indexArray# @ a w1 ww3 of ds { Unit# ipv ->
                                  ipv }) of wild1 { () ->
                          $wgo2 w1 ww2 (GHC.Prim.+# ww3 1#) } }
                 } in
                 $wgo2 ww1 (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 0#) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S,U><L,1*U(U,U)>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 let {
                   f :: [GHC.Types.Char] = GHC.CString.unpackCString# "fromList "#
                 } in
                 let {
                   eta :: [(GHC.Word.Word8, a)]
                   = case w1 of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                     letrec {
                       $wgo2 :: GHC.Prim.Array# a
                                -> GHC.Prim.Int#
                                -> GHC.Prim.Word#
                                -> GHC.Prim.Word#
                                -> GHC.Prim.Word#
                                -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
                         {- Arity: 5, Strictness: <L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
                       = \ (w2 :: GHC.Prim.Array# a)
                           (ww1 :: GHC.Prim.Int#)
                           (ww2 :: GHC.Prim.Word#)
                           (ww3 :: GHC.Prim.Word#)
                           (ww4 :: GHC.Prim.Word#) ->
                         case ww2 of wild1 {
                           DEFAULT
                           -> case GHC.Prim.and# wild1 ww3 of wild2 {
                                DEFAULT
                                -> GHC.Types.:
                                     @ (Data.Trie.ArrayMapped.SparseArray.Key, a)
                                     (GHC.Word.W8# ww4,
                                      case GHC.Prim.indexArray# @ a w2 ww1 of ds { Unit# ipv ->
                                      ipv })
                                     ($wgo2
                                        w2
                                        (GHC.Prim.+# ww1 1#)
                                        (GHC.Prim.xor# wild1 ww3)
                                        (GHC.Prim.uncheckedShiftL# ww3 1#)
                                        (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww4 1##)))
                                0##
                                -> $wgo2
                                     w2
                                     ww1
                                     wild1
                                     (GHC.Prim.uncheckedShiftL# ww3 1#)
                                     (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ww4 1##)) }
                           0## -> GHC.Types.[] @ (Data.Trie.ArrayMapped.SparseArray.Key, a) }
                     } in
                     $wgo2 xs 0# dt 1## 0## }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       f
                       (GHC.Show.showList__
                          @ (GHC.Word.Word8, a)
                          (\ (w3 :: (GHC.Word.Word8, a)) (w4 :: GHC.Base.String)[OneShot] ->
                           case w3 of ww1 { (,) ww2 ww3 ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (case ww2 of wild { GHC.Word.W8# x# ->
                              case GHC.Show.$wshowSignedInt
                                     0#
                                     (GHC.Prim.word2Int# x#)
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows7
                                        (GHC.Show.$fShow(,)_$sgo
                                           (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w4)
                                           (GHC.Show.showsPrec @ a w GHC.Show.shows22 ww3)
                                           (GHC.Types.[]
                                              @ GHC.Show.ShowS))) of ww4 { (#,#) ww5 ww6 ->
                              GHC.Types.: @ GHC.Types.Char ww5 ww6 } }) })
                          eta
                          x)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww 10#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)) }) -}
39e004b1958e2df8670dca95fde5433e
  $w$csum ::
    GHC.Num.Num a =>
    GHC.Prim.Word# -> GHC.Prim.Array# a -> Data.Monoid.Sum a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(1*U,A,A,A,A,A,1*C1(U))><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldr'
                   @ a
                   @ (Data.Monoid.Sum a)
                   (let {
                      f :: a -> a -> a = GHC.Num.+ @ a w
                    } in
                    (\ (x :: a) -> f x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)
                     ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)))
                   (GHC.Num.fromInteger @ a w Data.Monoid.$fMonoidSum1)
                     `cast`
                   (Sym (Data.Monoid.N:Sum[0] <a>_R))
                   ww
                   ww1) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $w$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> f (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
  {- Arity: 4,
     Strictness: <S(S(C(C(S))L)LLLL),U(U(U,U),1*C1(U),C(C1(U)),A,A)><L,C(U)><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f w)
                   @ [b]
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                   (\ (w2 :: [b]) ->
                    Data.Trie.ArrayMapped.SparseArray.$wfromElems @ b ww w2)
                   (let {
                      $dFunctor :: GHC.Base.Functor f = GHC.Base.$p1Applicative @ f w
                    } in
                    Data.Trie.ArrayMapped.SparseArray.$w$cfoldr
                      @ a
                      @ (f [b])
                      (\ (x :: a) (ys :: f [b])[OneShot] ->
                       GHC.Base.<*>
                         @ f
                         w
                         @ [b]
                         @ [b]
                         (GHC.Base.fmap
                            @ f
                            $dFunctor
                            @ b
                            @ ([b] -> [b])
                            (GHC.Types.: @ b)
                            (w1 x))
                         ys)
                      (GHC.Base.pure @ f w @ [b] (GHC.Types.[] @ b))
                      ww
                      ww1)) -}
e5b6534831f2e84e7b589d78ac4e86af
  $wadjust ::
    (a -> a)
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <L,1*C1(U)><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Array# a) ->
                 let {
                   b :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ww)
                 } in
                 case GHC.Prim.and# ww1 b of wild {
                   DEFAULT
                   -> case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                             (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                maxN :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)
                              } in
                              case GHC.Prim.newArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     maxN
                                     (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                     eta of ds { (#,#) ipv ipv1 ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     0#
                                     ipv1
                                     0#
                                     maxN
                                     ipv of s' { DEFAULT ->
                              let {
                                i :: GHC.Prim.Int#
                                = GHC.Prim.word2Int#
                                    (GHC.Prim.popCnt#
                                       (GHC.Prim.and# ww1 (GHC.Prim.minusWord# b 1##)))
                              } in
                              case GHC.Prim.writeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     i
                                     (case GHC.Prim.indexArray# @ a ww2 i of ds1 { Unit# ipv2 ->
                                      w ipv2 })
                                     s' of s'1 { DEFAULT ->
                              case GHC.Prim.unsafeFreezeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     s'1 of ds1 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Data.Trie.ArrayMapped.SparseArray.SA
                                   @ a
                                   ww1
                                   ipv3 #) } } } }) of ds1 { (#,#) ipv ipv1 ->
                      ipv1 }
                   0## -> Data.Trie.ArrayMapped.SparseArray.SA @ a ww1 ww2 }) -}
5215fdf60369bf382b116a9c128f42b4
  $wadjust' ::
    (a -> a)
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <L,1*C1(U)><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Array# a) ->
                 let {
                   b :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ww)
                 } in
                 case GHC.Prim.and# ww1 b of wild {
                   DEFAULT
                   -> case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                             (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                maxN :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)
                              } in
                              case GHC.Prim.newArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     maxN
                                     (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                     eta of ds { (#,#) ipv ipv1 ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     0#
                                     ipv1
                                     0#
                                     maxN
                                     ipv of s' { DEFAULT ->
                              let {
                                i :: GHC.Prim.Int#
                                = GHC.Prim.word2Int#
                                    (GHC.Prim.popCnt#
                                       (GHC.Prim.and# ww1 (GHC.Prim.minusWord# b 1##)))
                              } in
                              case GHC.Prim.indexArray# @ a ww2 i of ds1 { Unit# ipv2 ->
                              case w ipv2 of x1 { DEFAULT ->
                              case GHC.Prim.writeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     i
                                     x1
                                     s' of s'1 { DEFAULT ->
                              case GHC.Prim.unsafeFreezeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     s'1 of ds2 { (#,#) ipv3 ipv4 ->
                              (# ipv3,
                                 Data.Trie.ArrayMapped.SparseArray.SA
                                   @ a
                                   ww1
                                   ipv4 #) } } } } } }) of ds1 { (#,#) ipv ipv1 ->
                      ipv1 }
                   0## -> Data.Trie.ArrayMapped.SparseArray.SA @ a ww1 ww2 }) -}
31c7db2c973d44b50883d805378410e9
  $wdelete ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Array# a) ->
                 let {
                   b :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ww)
                 } in
                 case GHC.Prim.and# ww1 b of wild {
                   DEFAULT
                   -> case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                             (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                maxN :: GHC.Prim.Int#
                                = GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)) 1#
                              } in
                              case GHC.Prim.newArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     maxN
                                     (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                     eta of ds { (#,#) ipv ipv1 ->
                              let {
                                i :: GHC.Prim.Int#
                                = GHC.Prim.word2Int#
                                    (GHC.Prim.popCnt#
                                       (GHC.Prim.and# ww1 (GHC.Prim.minusWord# b 1##)))
                              } in
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     0#
                                     ipv1
                                     0#
                                     i
                                     ipv of s' { DEFAULT ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     (GHC.Prim.+# i 1#)
                                     ipv1
                                     i
                                     (GHC.Prim.-# maxN i)
                                     s' of s'1 { DEFAULT ->
                              case GHC.Prim.unsafeFreezeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     s'1 of ds1 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Data.Trie.ArrayMapped.SparseArray.SA
                                   @ a
                                   (GHC.Prim.xor# ww1 b)
                                   ipv3 #) } } } }) of ds1 { (#,#) ipv ipv1 ->
                      ipv1 }
                   0## -> Data.Trie.ArrayMapped.SparseArray.SA @ a ww1 ww2 }) -}
43e9d88b260a8f958fc7041348c159b4
  $wdifferenceL ::
    GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <S,U><S,U><S,U><L,A>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Word# = GHC.Prim.and# ww (GHC.Prim.not# ww2)
                         } in
                         let {
                           ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv1
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv2 ipv3 ->
                         Data.Trie.ArrayMapped.SparseArray.$wgo
                           @ a
                           @ b
                           @ GHC.Prim.RealWorld
                           @ a
                           ww
                           ww1
                           ipv
                           ipv3
                           ipv1
                           0#
                           (GHC.Prim.and#
                              ipv
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv))))
                           ipv2 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
fdcc17dfdd9f386a058d942c05457b79
  $wfilter ::
    (a -> GHC.Types.Bool)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         let {
                           wild :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                           = Data.Trie.ArrayMapped.SparseArray.SA @ a ww ww1
                         } in
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray a #)
                             {- Arity: 5, Strictness: <S,U><L,U><L,U><L,U><S,U>, Inline: [0] -}
                           = \ (ww2 :: GHC.Prim.Int#)
                               (ww3 :: GHC.Prim.Word#)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww2 ipv) of wild1 {
                               GHC.Types.False
                               -> let {
                                    x :: a
                                    = case GHC.Prim.indexArray# @ a ww1 ww2 of ds1 { Unit# ipv3 ->
                                      ipv3 }
                                  } in
                                  case w x of wild2 {
                                    GHC.Types.False
                                    -> let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         ww4
                                         ww5
                                         w1
                                    GHC.Types.True
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv2
                                              ww4
                                              x
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.or# ww5 ww3)
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# ww2 ww4) of wild2 {
                                    GHC.Types.False
                                    -> case GHC.Prim.freezeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv2
                                              0#
                                              (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww5))
                                              w1 of ds1 { (#,#) ipv3 ipv4 ->
                                       (# ipv3,
                                          Data.Trie.ArrayMapped.SparseArray.SA @ a ww5 ipv4 #) }
                                    GHC.Types.True -> (# w1, wild #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           0#
                           0##
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
be4ca9412478f4a5e3f831ad0996a87e
  $wfilterMap ::
    (a -> GHC.Base.Maybe b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> GHC.Base.Maybe b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                             {- Arity: 5, Strictness: <S,U><L,U><L,U><L,U><S,U>, Inline: [0] -}
                           = \ (ww2 :: GHC.Prim.Int#)
                               (ww3 :: GHC.Prim.Word#)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww2 ipv) of wild {
                               GHC.Types.False
                               -> case w (case GHC.Prim.indexArray#
                                                 @ a
                                                 ww1
                                                 ww2 of ds1 { Unit# ipv3 ->
                                          ipv3 }) of wild1 {
                                    GHC.Base.Nothing
                                    -> let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         ww4
                                         ww5
                                         w1
                                    GHC.Base.Just y
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ b
                                              ipv2
                                              ww4
                                              y
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.or# ww5 ww3)
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# ww2 ww4) of wild1 {
                                    GHC.Types.False
                                    -> case GHC.Prim.freezeArray#
                                              @ GHC.Prim.RealWorld
                                              @ b
                                              ipv2
                                              0#
                                              (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww5))
                                              w1 of ds1 { (#,#) ipv3 ipv4 ->
                                       (# ipv3,
                                          Data.Trie.ArrayMapped.SparseArray.SA @ b ww5 ipv4 #) }
                                    GHC.Types.True
                                    -> case GHC.Prim.unsafeFreezeArray#
                                              @ GHC.Prim.RealWorld
                                              @ b
                                              ipv2
                                              w1 of ds1 { (#,#) ipv3 ipv4 ->
                                       (# ipv3,
                                          Data.Trie.ArrayMapped.SparseArray.SA @ b ww5 ipv4 #) } } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           0#
                           0##
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
2b8bb3be967c73ee67b237508874c2ae
  $wfilterMapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Base.Maybe b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key
                                  -> a -> GHC.Base.Maybe b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          let {
                            ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ b
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                         eta of ds { (#,#) ipv1 ipv2 ->
                                  letrec {
                                    go :: GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                                      {- Arity: 4 -}
                                    = \ (i :: GHC.Types.Int)
                                        (bi :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (j :: GHC.Types.Int)
                                        (q :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case i of i1 { GHC.Types.I# ipv3 ->
                                      case bi of bi1 { GHC.Types.W# ipv4 ->
                                      case j of j1 { GHC.Types.I# ipv5 ->
                                      case q of q1 { GHC.Types.W# ipv6 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.>=# ipv3 ipv) of wild {
                                        GHC.Types.False
                                        -> case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                        -> GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld
                                                                                                                        -> (# GHC.Prim.State#
                                                                                                                                GHC.Prim.RealWorld,
                                                                                                                              GHC.Prim.Int# #)}
                                                          (GHC.Prim.narrow32Int#
                                                             (GHC.Prim.word2Int# ipv4))
                                                          GHC.Prim.realWorld# of wild1 { (#,#) ds1 ds2 ->
                                                   GHC.Word.W8#
                                                     (GHC.Prim.narrow8Word#
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.narrow32Int# ds2))) })
                                                  (case GHC.Prim.indexArray#
                                                          @ a
                                                          ww1
                                                          ipv3 of ds1 { Unit# ipv7 ->
                                                   ipv7 }) of wild1 {
                                             GHC.Base.Nothing
                                             -> go
                                                  (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                  (let {
                                                     p :: GHC.Prim.Word#
                                                     = GHC.Prim.and#
                                                         ww
                                                         (GHC.Prim.int2Word#
                                                            (GHC.Prim.negateInt#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.uncheckedShiftL#
                                                                     ipv4
                                                                     1#))))
                                                   } in
                                                   GHC.Types.W#
                                                     (GHC.Prim.and#
                                                        p
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.negateInt#
                                                              (GHC.Prim.word2Int# p)))))
                                                  j1
                                                  q1
                                             GHC.Base.Just y
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ b
                                                        ipv2
                                                        ipv5
                                                        y
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv4
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv6 ipv4)))
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                         b>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             b>_R)) }
                                        GHC.Types.True
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.==# ipv3 ipv5) of wild1 {
                                             GHC.Types.False
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.freezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ b
                                                        ipv2
                                                        0#
                                                        (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv6))
                                                        s of ds1 { (#,#) ipv7 ipv8 ->
                                                 (# ipv7,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ b
                                                      ipv6
                                                      ipv8 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             b>_R))
                                             GHC.Types.True
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.unsafeFreezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ b
                                                        ipv2
                                                        s of ds1 { (#,#) ipv7 ipv8 ->
                                                 (# ipv7,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ b
                                                      ipv6
                                                      ipv8 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             b>_R)) } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ww
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <Data.Trie.ArrayMapped.SparseArray.SparseArray b>_R)
                                    ipv1 }) of ds1 { (#,#) ipv1 ipv2 ->
                          ipv2 }) -}
a7e09ebeea685c4d76fad4c3a808c5d1
  $wfilterWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          let {
                            wild :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                            = Data.Trie.ArrayMapped.SparseArray.SA @ a ww ww1
                          } in
                          let {
                            ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ a
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                         eta of ds { (#,#) ipv1 ipv2 ->
                                  letrec {
                                    go :: GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                      {- Arity: 4 -}
                                    = \ (i :: GHC.Types.Int)
                                        (bi :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (j :: GHC.Types.Int)
                                        (q :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case i of i1 { GHC.Types.I# ipv3 ->
                                      case bi of bi1 { GHC.Types.W# ipv4 ->
                                      case j of j1 { GHC.Types.I# ipv5 ->
                                      case q of q1 { GHC.Types.W# ipv6 ->
                                      let {
                                        x :: a
                                        = case GHC.Prim.indexArray#
                                                 @ a
                                                 ww1
                                                 ipv3 of ds1 { Unit# ipv7 ->
                                          ipv7 }
                                      } in
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.>=# ipv3 ipv) of wild1 {
                                        GHC.Types.False
                                        -> case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                        -> GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld
                                                                                                                        -> (# GHC.Prim.State#
                                                                                                                                GHC.Prim.RealWorld,
                                                                                                                              GHC.Prim.Int# #)}
                                                          (GHC.Prim.narrow32Int#
                                                             (GHC.Prim.word2Int# ipv4))
                                                          GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                                                   GHC.Word.W8#
                                                     (GHC.Prim.narrow8Word#
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.narrow32Int# ds2))) })
                                                  x of wild2 {
                                             GHC.Types.False
                                             -> go
                                                  (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                  (let {
                                                     p :: GHC.Prim.Word#
                                                     = GHC.Prim.and#
                                                         ww
                                                         (GHC.Prim.int2Word#
                                                            (GHC.Prim.negateInt#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.uncheckedShiftL#
                                                                     ipv4
                                                                     1#))))
                                                   } in
                                                   GHC.Types.W#
                                                     (GHC.Prim.and#
                                                        p
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.negateInt#
                                                              (GHC.Prim.word2Int# p)))))
                                                  j1
                                                  q1
                                             GHC.Types.True
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ a
                                                        ipv2
                                                        ipv5
                                                        x
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv4
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv6 ipv4)))
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                         a>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             a>_R)) }
                                        GHC.Types.True
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.==# ipv3 ipv5) of wild2 {
                                             GHC.Types.False
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.freezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ a
                                                        ipv2
                                                        0#
                                                        (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv6))
                                                        s of ds1 { (#,#) ipv7 ipv8 ->
                                                 (# ipv7,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ a
                                                      ipv6
                                                      ipv8 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             a>_R))
                                             GHC.Types.True
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 (# s1, wild #))
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             a>_R)) } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ww
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R)
                                    ipv1 }) of ds1 { (#,#) ipv1 ipv2 ->
                          ipv2 }) -}
6749e1774daa12c802c8dac9df61b7f3
  $wfoldL ::
    (b -> a -> Data.Either.Either b c)
    -> b
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Either.Either b c
  {- Arity: 4, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ b
                            @ a
                            @ c
                            (w :: b -> a -> Data.Either.Either b c)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> GHC.Types.Int -> GHC.Types.Int -> b -> Data.Either.Either b c
                              {- Arity: 4 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (n :: GHC.Types.Int)
                                (i :: GHC.Types.Int)
                                (z :: b) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case i of i1 { GHC.Types.I# ipv1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# ipv1 ipv) of wild {
                                GHC.Types.False -> Data.Either.Left @ b @ c z
                                GHC.Types.True
                                -> case w z
                                          (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv1 of ds { Unit# ipv2 ->
                                           ipv2 }) of wild1 {
                                     Data.Either.Left z'
                                     -> go xs n1 (GHC.Types.I# (GHC.Prim.+# ipv1 1#)) z'
                                     Data.Either.Right ds -> wild1 } } } }
                          } in
                          go
                            ww1
                            (GHC.Types.I# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)))
                            (GHC.Types.I# 0#)
                            w1) -}
7a9ba44000db58d546b86f0ab586054f
  $wfoldR ::
    (a -> b -> Data.Either.Either b c)
    -> b
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Either.Either b c
  {- Arity: 4, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            @ c
                            (w :: a -> b -> Data.Either.Either b c)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> GHC.Types.Int -> b -> Data.Either.Either b c
                              {- Arity: 3 -}
                            = \ (xs :: GHC.Prim.Array# a) (n :: GHC.Types.Int) (z :: b) ->
                              case n of n1 { GHC.Types.I# ipv ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ipv 0#) of wild {
                                GHC.Types.False -> Data.Either.Left @ b @ c z
                                GHC.Types.True
                                -> case w (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv of ds { Unit# ipv1 ->
                                           ipv1 })
                                          z of wild1 {
                                     Data.Either.Left z'
                                     -> go xs (GHC.Types.I# (GHC.Prim.-# ipv 1#)) z'
                                     Data.Either.Right ds -> wild1 } } }
                          } in
                          go
                            ww1
                            (GHC.Types.I#
                               (GHC.Prim.-# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)) 1#))
                            w1) -}
144f0eb80a533c76f5a53a54fee24980
  $wfoldlWithKey ::
    (b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,1*U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ b
                            @ a
                            (w :: b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> GHC.Types.Int
                                  -> GHC.Types.Word
                                  -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                  -> GHC.Word.Word8
                                  -> b
                                  -> b
                              {- Arity: 6 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (i :: GHC.Types.Int)
                                (p :: GHC.Types.Word)
                                (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                (k :: GHC.Word.Word8)
                                (z :: b) ->
                              case i of i1 { GHC.Types.I# ipv ->
                              case p of p1 { GHC.Types.W# ipv1 ->
                              case b1 of b2 { GHC.Types.W# ipv2 ->
                              case k of k1 { GHC.Word.W8# ipv3 ->
                              case ipv1 of wild {
                                DEFAULT
                                -> case GHC.Prim.and# wild ipv2 of wild1 {
                                     DEFAULT
                                     -> go
                                          xs
                                          (GHC.Types.I# (GHC.Prim.+# ipv 1#))
                                          (GHC.Types.W# (GHC.Prim.xor# wild ipv2))
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##)))
                                          (w z
                                             k1
                                             (case GHC.Prim.indexArray#
                                                     @ a
                                                     xs
                                                     ipv of ds { Unit# ipv4 ->
                                              ipv4 }))
                                     0##
                                     -> go
                                          xs
                                          i1
                                          p1
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##)))
                                          z }
                                0## -> z } } } } }
                          } in
                          case w1 of z0 { DEFAULT ->
                          go
                            ww1
                            (GHC.Types.I# 0#)
                            (GHC.Types.W# ww)
                            (GHC.Types.W# 1##)
                            (GHC.Word.W8# 0##)
                            z0 }) -}
6c3ae2a8308d94d18b4698a6cbeb4640
  $wfoldlWithKey' ::
    (b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,1*U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ b
                            @ a
                            (w :: b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> GHC.Types.Int
                                  -> GHC.Types.Word
                                  -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                  -> GHC.Word.Word8
                                  -> b
                                  -> b
                              {- Arity: 6 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (i :: GHC.Types.Int)
                                (p :: GHC.Types.Word)
                                (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                (k :: GHC.Word.Word8)
                                (z :: b) ->
                              case i of i1 { GHC.Types.I# ipv ->
                              case p of p1 { GHC.Types.W# ipv1 ->
                              case b1 of b2 { GHC.Types.W# ipv2 ->
                              case k of k1 { GHC.Word.W8# ipv3 ->
                              case z of z1 { DEFAULT ->
                              case ipv1 of wild {
                                DEFAULT
                                -> case GHC.Prim.and# wild ipv2 of wild1 {
                                     DEFAULT
                                     -> case w z1
                                               k1
                                               (case GHC.Prim.indexArray#
                                                       @ a
                                                       xs
                                                       ipv of ds { Unit# ipv4 ->
                                                ipv4 }) of x1 { DEFAULT ->
                                        go
                                          xs
                                          (GHC.Types.I# (GHC.Prim.+# ipv 1#))
                                          (GHC.Types.W# (GHC.Prim.xor# wild ipv2))
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##)))
                                          x1 }
                                     0##
                                     -> go
                                          xs
                                          i1
                                          p1
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##)))
                                          z1 }
                                0## -> z1 } } } } } }
                          } in
                          case w1 of z0 { DEFAULT ->
                          go
                            ww1
                            (GHC.Types.I# 0#)
                            (GHC.Types.W# ww)
                            (GHC.Types.W# 1##)
                            (GHC.Word.W8# 0##)
                            z0 }) -}
5924beb650462bf0e8edb5793a70cafe
  $wfoldrWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
    -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><L,U><S,U><S,U>, Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> Data.Trie.ArrayMapped.SparseArray.Index
                                  -> GHC.Types.Word
                                  -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                  -> Data.Trie.ArrayMapped.SparseArray.Key
                                  -> b
                              {- Arity: 5 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                                (p :: GHC.Types.Word)
                                (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                              case i of i1 { GHC.Types.I# ipv ->
                              case p of p1 { GHC.Types.W# ipv1 ->
                              case b1 of b2 { GHC.Types.W# ipv2 ->
                              case k of k1 { GHC.Word.W8# ipv3 ->
                              case ipv1 of wild {
                                DEFAULT
                                -> case GHC.Prim.and# wild ipv2 of wild1 {
                                     DEFAULT
                                     -> w k1
                                          (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv of ds { Unit# ipv4 ->
                                           ipv4 })
                                          (go
                                             xs
                                             (GHC.Types.I# (GHC.Prim.+# ipv 1#))
                                             (GHC.Types.W# (GHC.Prim.xor# wild ipv2))
                                             (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                             (GHC.Word.W8#
                                                (GHC.Prim.narrow8Word#
                                                   (GHC.Prim.plusWord# ipv3 1##))))
                                     0##
                                     -> go
                                          xs
                                          i1
                                          p1
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word#
                                                (GHC.Prim.plusWord# ipv3 1##))) }
                                0## -> w1 } } } } }
                          } in
                          go
                            ww1
                            (GHC.Types.I# 0#)
                            (GHC.Types.W# ww)
                            (GHC.Types.W# 1##)
                            (GHC.Word.W8# 0##)) -}
01cd2fea7133822edbbe9f8815dccce4
  $wfoldrWithKey' ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
    -> b -> GHC.Prim.Word# -> GHC.Prim.Array# a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,U><S,U><S,U>, Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
                            (w1 :: b)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          letrec {
                            go :: GHC.Prim.Array# a
                                  -> Data.Trie.ArrayMapped.SparseArray.Index
                                  -> GHC.Types.Word
                                  -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                  -> Data.Trie.ArrayMapped.SparseArray.Key
                                  -> b
                              {- Arity: 5 -}
                            = \ (xs :: GHC.Prim.Array# a)
                                (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                                (p :: GHC.Types.Word)
                                (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                              case i of i1 { GHC.Types.I# ipv ->
                              case p of p1 { GHC.Types.W# ipv1 ->
                              case b1 of b2 { GHC.Types.W# ipv2 ->
                              case k of k1 { GHC.Word.W8# ipv3 ->
                              case ipv1 of wild {
                                DEFAULT
                                -> case GHC.Prim.and# wild ipv2 of wild1 {
                                     DEFAULT
                                     -> case go
                                               xs
                                               (GHC.Types.I# (GHC.Prim.+# ipv 1#))
                                               (GHC.Types.W# (GHC.Prim.xor# wild ipv2))
                                               (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                               (GHC.Word.W8#
                                                  (GHC.Prim.narrow8Word#
                                                     (GHC.Prim.plusWord#
                                                        ipv3
                                                        1##))) of x1 { DEFAULT ->
                                        w k1
                                          (case GHC.Prim.indexArray#
                                                  @ a
                                                  xs
                                                  ipv of ds { Unit# ipv4 ->
                                           ipv4 })
                                          x1 }
                                     0##
                                     -> go
                                          xs
                                          i1
                                          p1
                                          (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                          (GHC.Word.W8#
                                             (GHC.Prim.narrow8Word#
                                                (GHC.Prim.plusWord# ipv3 1##))) }
                                0## -> w1 } } } } }
                          } in
                          go
                            ww1
                            (GHC.Types.I# 0#)
                            (GHC.Types.W# ww)
                            (GHC.Types.W# 1##)
                            (GHC.Word.W8# 0##)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $wfromElems ::
    GHC.Prim.Word#
    -> [a] -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Word#) (w :: [a]) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                n
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv ipv1 ->
                         letrec {
                           $wgo2 :: forall s a1 t.
                                    GHC.Prim.Word#
                                    -> GHC.Prim.MutableArray# s a1
                                    -> t
                                    -> GHC.Prim.Int#
                                    -> [a1]
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray a1 #)
                             {- Arity: 6, Strictness: <L,U><S,U><S,1*U><L,U><S,1*U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               @ a1
                               @ t
                               (ww1 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.MutableArray# s a1)
                               (w2 :: t)
                               (ww2 :: GHC.Prim.Int#)
                               (w3 :: [a1])
                               (w4 :: GHC.Prim.State# s)[OneShot] ->
                             case w2 of _n { DEFAULT ->
                             case w3 of wild {
                               []
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ a1
                                         w1
                                         w4 of ds1 { (#,#) ipv2 ipv3 ->
                                  (# ipv2, Data.Trie.ArrayMapped.SparseArray.SA @ a1 ww1 ipv3 #) }
                               : ipv2 ipv3
                               -> case GHC.Prim.writeArray#
                                         @ s
                                         @ a1
                                         w1
                                         ww2
                                         ipv2
                                         w4 of s' { DEFAULT ->
                                  $wgo2 @ s @ a1 @ t ww1 w1 _n (GHC.Prim.+# ww2 1#) ipv3 s' } } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           @ a
                           @ GHC.Types.Int
                           ww
                           ipv1
                           (GHC.Types.I# n)
                           0#
                           w
                           ipv }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
60fa33c45a77c576c7bf6acbe14a044e
  $wfromList_ ::
    GHC.Prim.Int#
    -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
dd35b93dab6e993974952a94b6e78e1a
  $wgo ::
    GHC.Prim.Word#
    -> GHC.Prim.Array# a1
    -> GHC.Prim.Word#
    -> GHC.Prim.MutableArray# s a1
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Word#
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Trie.ArrayMapped.SparseArray.SparseArray a1 #)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S,U><S,U><S,U><L,U><S,U>,
     Inline: [0] -}
ebbf6eecb1499ccef883308be5c9b7f1
  $wgo1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a1
    -> GHC.Prim.Word#
    -> GHC.Prim.MutableArray# s a1
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Trie.ArrayMapped.SparseArray.SparseArray a1 #)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,U><L,U><L,U><S,U><L,U><S,U><S,U>,
     Inline: [0] -}
5134695553d83f855da92f4aba77121a
  $winsert ::
    GHC.Prim.Word#
    -> a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <S,U><L,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Word#)
                   (w :: a)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Array# a) ->
                 let {
                   b :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ww)
                 } in
                 let {
                   i :: GHC.Prim.Int#
                   = GHC.Prim.word2Int#
                       (GHC.Prim.popCnt# (GHC.Prim.and# ww1 (GHC.Prim.minusWord# b 1##)))
                 } in
                 case GHC.Prim.and# ww1 b of wild {
                   DEFAULT
                   -> case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                             (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                maxN :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)
                              } in
                              case GHC.Prim.newArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     maxN
                                     (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                     eta of ds { (#,#) ipv ipv1 ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     0#
                                     ipv1
                                     0#
                                     maxN
                                     ipv of s' { DEFAULT ->
                              case GHC.Prim.writeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     i
                                     w
                                     s' of s'1 { DEFAULT ->
                              case GHC.Prim.unsafeFreezeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     s'1 of ds1 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Data.Trie.ArrayMapped.SparseArray.SA
                                   @ a
                                   ww1
                                   ipv3 #) } } } }) of ds1 { (#,#) ipv ipv1 ->
                      ipv1 }
                   0##
                   -> case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                             (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                maxN :: GHC.Prim.Int#
                                = GHC.Prim.+# (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww1)) 1#
                              } in
                              case GHC.Prim.newArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     maxN
                                     (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                     eta of ds { (#,#) ipv ipv1 ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     0#
                                     ipv1
                                     0#
                                     i
                                     ipv of s' { DEFAULT ->
                              case GHC.Prim.writeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     i
                                     w
                                     s' of s'1 { DEFAULT ->
                              case GHC.Prim.copyArray#
                                     @ a
                                     @ GHC.Prim.RealWorld
                                     ww2
                                     i
                                     ipv1
                                     (GHC.Prim.+# i 1#)
                                     (GHC.Prim.-# maxN i)
                                     s'1 of s'2 { DEFAULT ->
                              case GHC.Prim.unsafeFreezeArray#
                                     @ GHC.Prim.RealWorld
                                     @ a
                                     ipv1
                                     s'2 of ds1 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Data.Trie.ArrayMapped.SparseArray.SA
                                   @ a
                                   (GHC.Prim.or# ww1 b)
                                   ipv3 #) } } } } }) of ds1 { (#,#) ipv ipv1 ->
                      ipv1 } }) -}
2ec05ec89019dcfc46cf71abffd8fdee
  $wintersectionL ::
    GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <S,U><S,U><S,U><L,A>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Word# = GHC.Prim.and# ww ww2
                         } in
                         let {
                           ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv1
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv2 ipv3 ->
                         Data.Trie.ArrayMapped.SparseArray.$wgo1
                           @ a
                           @ b
                           @ GHC.Prim.RealWorld
                           @ a
                           ipv1
                           ww
                           ww1
                           ipv
                           ipv3
                           (GHC.Prim.and#
                              ipv
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv))))
                           0#
                           ipv2 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
a2dc277ad35a04df3b5ecf204185ca22
  $wintersectionWith ::
    (a -> b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 5, Strictness: <L,C(C1(U))><S,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Word# = GHC.Prim.and# ww ww2
                         } in
                         let {
                           ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv1
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv2 ipv3 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Array# b
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.MutableArray# s c
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 10,
                                Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><S,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww6 :: GHC.Prim.Word#)
                               (w2 :: GHC.Prim.Array# b)
                               (ww7 :: GHC.Prim.Word#)
                               (w3 :: GHC.Prim.MutableArray# s c)
                               (ww8 :: GHC.Prim.Word#)
                               (ww9 :: GHC.Prim.Int#)
                               (w4 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww9 ww4) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.writeArray#
                                         @ s
                                         @ c
                                         w3
                                         ww9
                                         (w (case GHC.Prim.indexArray#
                                                    @ a
                                                    w1
                                                    (GHC.Prim.word2Int#
                                                       (GHC.Prim.popCnt#
                                                          (GHC.Prim.and#
                                                             ww5
                                                             (GHC.Prim.minusWord#
                                                                ww8
                                                                1##)))) of ds1 { Unit# ipv4 ->
                                             ipv4 })
                                            (case GHC.Prim.indexArray#
                                                    @ b
                                                    w2
                                                    (GHC.Prim.word2Int#
                                                       (GHC.Prim.popCnt#
                                                          (GHC.Prim.and#
                                                             ww6
                                                             (GHC.Prim.minusWord#
                                                                ww8
                                                                1##)))) of ds1 { Unit# ipv4 ->
                                             ipv4 }))
                                         w4 of s' { DEFAULT ->
                                  let {
                                    p :: GHC.Prim.Word#
                                    = GHC.Prim.and#
                                        ww7
                                        (GHC.Prim.int2Word#
                                           (GHC.Prim.negateInt#
                                              (GHC.Prim.word2Int#
                                                 (GHC.Prim.uncheckedShiftL# ww8 1#))))
                                  } in
                                  $wgo2
                                    @ s
                                    ww4
                                    ww5
                                    w1
                                    ww6
                                    w2
                                    ww7
                                    w3
                                    (GHC.Prim.and#
                                       p
                                       (GHC.Prim.int2Word#
                                          (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                    (GHC.Prim.+# ww9 1#)
                                    s' }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ c
                                         w3
                                         w4 of ds1 { (#,#) ipv4 ipv5 ->
                                  (# ipv4, Data.Trie.ArrayMapped.SparseArray.SA @ c ww7 ipv5 #) } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ipv1
                           ww
                           ww1
                           ww2
                           ww3
                           ipv
                           ipv3
                           (GHC.Prim.and#
                              ipv
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv))))
                           0#
                           ipv2 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
16826ed28ad1834ff715e54de4709100
  $wintersectionWith' ::
    (a -> b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 5, Strictness: <L,C(C1(U))><S,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Word# = GHC.Prim.and# ww ww2
                         } in
                         let {
                           ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv1
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv2 ipv3 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Array# b
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.MutableArray# s c
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 10,
                                Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><S,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww6 :: GHC.Prim.Word#)
                               (w2 :: GHC.Prim.Array# b)
                               (ww7 :: GHC.Prim.Word#)
                               (w3 :: GHC.Prim.MutableArray# s c)
                               (ww8 :: GHC.Prim.Word#)
                               (ww9 :: GHC.Prim.Int#)
                               (w4 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww9 ww4) of wild {
                               GHC.Types.False
                               -> case w (case GHC.Prim.indexArray#
                                                 @ a
                                                 w1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.popCnt#
                                                       (GHC.Prim.and#
                                                          ww5
                                                          (GHC.Prim.minusWord#
                                                             ww8
                                                             1##)))) of ds1 { Unit# ipv4 ->
                                          ipv4 })
                                         (case GHC.Prim.indexArray#
                                                 @ b
                                                 w2
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.popCnt#
                                                       (GHC.Prim.and#
                                                          ww6
                                                          (GHC.Prim.minusWord#
                                                             ww8
                                                             1##)))) of ds1 { Unit# ipv4 ->
                                          ipv4 }) of x1 { DEFAULT ->
                                  case GHC.Prim.writeArray# @ s @ c w3 ww9 x1 w4 of s' { DEFAULT ->
                                  let {
                                    p :: GHC.Prim.Word#
                                    = GHC.Prim.and#
                                        ww7
                                        (GHC.Prim.int2Word#
                                           (GHC.Prim.negateInt#
                                              (GHC.Prim.word2Int#
                                                 (GHC.Prim.uncheckedShiftL# ww8 1#))))
                                  } in
                                  $wgo2
                                    @ s
                                    ww4
                                    ww5
                                    w1
                                    ww6
                                    w2
                                    ww7
                                    w3
                                    (GHC.Prim.and#
                                       p
                                       (GHC.Prim.int2Word#
                                          (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                    (GHC.Prim.+# ww9 1#)
                                    s' } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ c
                                         w3
                                         w4 of ds1 { (#,#) ipv4 ipv5 ->
                                  (# ipv4, Data.Trie.ArrayMapped.SparseArray.SA @ c ww7 ipv5 #) } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ipv1
                           ww
                           ww1
                           ww2
                           ww3
                           ipv
                           ipv3
                           (GHC.Prim.and#
                              ipv
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv))))
                           0#
                           ipv2 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $wmap ::
    (a -> b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.MutableArray# s b
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                             {- Arity: 6, Strictness: <L,U><L,U><S,U><S,U><S,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww2 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww3 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.MutableArray# s b)
                               (ww4 :: GHC.Prim.Int#)
                               (w3 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# ww4 ww3) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ b
                                         w2
                                         w3 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ b ww2 ipv4 #) }
                               GHC.Types.True
                               -> case GHC.Prim.writeArray#
                                         @ s
                                         @ b
                                         w2
                                         ww4
                                         (case GHC.Prim.indexArray#
                                                 @ a
                                                 w1
                                                 ww4 of ds1 { Unit# ipv3 ->
                                          w ipv3 })
                                         w3 of s' { DEFAULT ->
                                  $wgo2 @ s ww2 w1 ww3 w2 (GHC.Prim.+# ww4 1#) s' } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ww
                           ww1
                           ipv
                           ipv2
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  $wmap' ::
    (a -> b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.MutableArray# s b
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                             {- Arity: 6, Strictness: <L,U><L,U><S,U><S,U><S,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww2 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww3 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.MutableArray# s b)
                               (ww4 :: GHC.Prim.Int#)
                               (w3 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# ww4 ww3) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ b
                                         w2
                                         w3 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ b ww2 ipv4 #) }
                               GHC.Types.True
                               -> case GHC.Prim.indexArray# @ a w1 ww4 of ds1 { Unit# ipv3 ->
                                  case w ipv3 of x1 { DEFAULT ->
                                  case GHC.Prim.writeArray# @ s @ b w2 ww4 x1 w3 of s' { DEFAULT ->
                                  $wgo2 @ s ww2 w1 ww3 w2 (GHC.Prim.+# ww4 1#) s' } } } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ww
                           ww1
                           ipv
                           ipv2
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
59ba463dd6bf29fb119ac597f713618b
  $wmapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.MutableArray# s b
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                             {- Arity: 7, Strictness: <L,U><L,U><S,U><S,U><S,U><L,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww2 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww3 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.MutableArray# s b)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w3 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# ww4 ww3) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ b
                                         w2
                                         w3 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ b ww2 ipv4 #) }
                               GHC.Types.True
                               -> case GHC.Prim.writeArray#
                                         @ s
                                         @ b
                                         w2
                                         ww4
                                         (case GHC.Prim.indexArray#
                                                 @ a
                                                 w1
                                                 ww4 of ds1 { Unit# ipv3 ->
                                          w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                  -> GHC.Prim.State#
                                                                                                                       GHC.Prim.RealWorld
                                                                                                                  -> (# GHC.Prim.State#
                                                                                                                          GHC.Prim.RealWorld,
                                                                                                                        GHC.Prim.Int# #)}
                                                    (GHC.Prim.narrow32Int# (GHC.Prim.word2Int# ww5))
                                                    GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                                             GHC.Word.W8#
                                               (GHC.Prim.narrow8Word#
                                                  (GHC.Prim.int2Word#
                                                     (GHC.Prim.narrow32Int# ds3))) })
                                            ipv3 })
                                         w3 of s' { DEFAULT ->
                                  let {
                                    p :: GHC.Prim.Word#
                                    = GHC.Prim.and#
                                        ww2
                                        (GHC.Prim.int2Word#
                                           (GHC.Prim.negateInt#
                                              (GHC.Prim.word2Int#
                                                 (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                  } in
                                  $wgo2
                                    @ s
                                    ww2
                                    w1
                                    ww3
                                    w2
                                    (GHC.Prim.+# ww4 1#)
                                    (GHC.Prim.and#
                                       p
                                       (GHC.Prim.int2Word#
                                          (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                    s' } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ww
                           ww1
                           ipv
                           ipv2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
38cbdc37285c16ba9c0366ad23339af6
  $wmapWithKey' ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: forall s.
                                    GHC.Prim.Word#
                                    -> GHC.Prim.Array# a
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.MutableArray# s b
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# s
                                    -> (# GHC.Prim.State# s,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                             {- Arity: 7, Strictness: <L,U><L,U><S,U><S,U><S,U><L,U><S,U>,
                                Inline: [0] -}
                           = \ @ s
                               (ww2 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.Array# a)
                               (ww3 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.MutableArray# s b)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (w3 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# ww4 ww3) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ s
                                         @ b
                                         w2
                                         w3 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ b ww2 ipv4 #) }
                               GHC.Types.True
                               -> case GHC.Prim.indexArray# @ a w1 ww4 of ds1 { Unit# ipv3 ->
                                  case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                               -> GHC.Prim.State#
                                                                                                                    GHC.Prim.RealWorld
                                                                                                               -> (# GHC.Prim.State#
                                                                                                                       GHC.Prim.RealWorld,
                                                                                                                     GHC.Prim.Int# #)}
                                                 (GHC.Prim.narrow32Int# (GHC.Prim.word2Int# ww5))
                                                 GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                                          GHC.Word.W8#
                                            (GHC.Prim.narrow8Word#
                                               (GHC.Prim.int2Word# (GHC.Prim.narrow32Int# ds3))) })
                                         ipv3 of x1 { DEFAULT ->
                                  case GHC.Prim.writeArray# @ s @ b w2 ww4 x1 w3 of s' { DEFAULT ->
                                  let {
                                    p :: GHC.Prim.Word#
                                    = GHC.Prim.and#
                                        ww2
                                        (GHC.Prim.int2Word#
                                           (GHC.Prim.negateInt#
                                              (GHC.Prim.word2Int#
                                                 (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                  } in
                                  $wgo2
                                    @ s
                                    ww2
                                    w1
                                    ww3
                                    w2
                                    (GHC.Prim.+# ww4 1#)
                                    (GHC.Prim.and#
                                       p
                                       (GHC.Prim.int2Word#
                                          (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                    s' } } } }
                         } in
                         $wgo2
                           @ GHC.Prim.RealWorld
                           ww
                           ww1
                           ipv
                           ipv2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
1d39465bf94c0f8a67b411f4bb755c8c
  $wpartition ::
    (a -> GHC.Types.Bool)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
        Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
                           Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                ipv1 of ds1 { (#,#) ipv3 ipv4 ->
                         let {
                           wild :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                           = Data.Trie.ArrayMapped.SparseArray.SA @ a ww ww1
                         } in
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
                                           Data.Trie.ArrayMapped.SparseArray.SparseArray a) #)
                             {- Arity: 7, Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><S,U>,
                                Inline: [0] -}
                           = \ (ww2 :: GHC.Prim.Int#)
                               (ww3 :: GHC.Prim.Word#)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (ww7 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww2 ipv) of wild1 {
                               GHC.Types.False
                               -> let {
                                    x :: a
                                    = case GHC.Prim.indexArray# @ a ww1 ww2 of ds2 { Unit# ipv5 ->
                                      ipv5 }
                                  } in
                                  case w x of wild2 {
                                    GHC.Types.False
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv4
                                              ww6
                                              x
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         ww4
                                         ww5
                                         (GHC.Prim.+# ww6 1#)
                                         (GHC.Prim.or# ww7 ww3)
                                         s' }
                                    GHC.Types.True
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv2
                                              ww4
                                              x
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.or# ww5 ww3)
                                         ww6
                                         ww7
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# ww2 ww4) of wild2 {
                                    GHC.Types.False
                                    -> case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# ww2 ww6) of wild3 {
                                         GHC.Types.False
                                         -> case GHC.Prim.freezeArray#
                                                   @ GHC.Prim.RealWorld
                                                   @ a
                                                   ipv2
                                                   0#
                                                   (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww5))
                                                   w1 of ds2 { (#,#) ipv5 ipv6 ->
                                            case GHC.Prim.freezeArray#
                                                   @ GHC.Prim.RealWorld
                                                   @ a
                                                   ipv4
                                                   0#
                                                   (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww7))
                                                   ipv5 of ds3 { (#,#) ipv7 ipv8 ->
                                            (# ipv7,
                                               (Data.Trie.ArrayMapped.SparseArray.SA @ a ww5 ipv6,
                                                Data.Trie.ArrayMapped.SparseArray.SA
                                                  @ a
                                                  ww7
                                                  ipv8) #) } }
                                         GHC.Types.True
                                         -> (# w1,
                                               (Data.Trie.ArrayMapped.SparseArray.empty @ a,
                                                wild) #) }
                                    GHC.Types.True
                                    -> (# w1,
                                          (wild, Data.Trie.ArrayMapped.SparseArray.empty @ a) #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           0#
                           0##
                           0#
                           0##
                           ipv3 } }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
11efa6e586fdfbe1a9a74c3a645ed29a
  $wpartitionMap ::
    (a -> Data.Either.Either b c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
        Data.Trie.ArrayMapped.SparseArray.SparseArray c)
  {- Arity: 3, Strictness: <L,C(U)><S,U><S,U>, Inline: NOINLINE[0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: a -> Data.Either.Either b c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
                           Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                         } in
                         case GHC.Prim.newArray#
                                @ b
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                ipv1 of ds1 { (#,#) ipv3 ipv4 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
                                           Data.Trie.ArrayMapped.SparseArray.SparseArray c) #)
                             {- Arity: 7, Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><S,U>,
                                Inline: [0] -}
                           = \ (ww2 :: GHC.Prim.Int#)
                               (ww3 :: GHC.Prim.Word#)
                               (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (ww7 :: GHC.Prim.Word#)
                               (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww2 ipv) of wild {
                               GHC.Types.False
                               -> case w (case GHC.Prim.indexArray#
                                                 @ a
                                                 ww1
                                                 ww2 of ds2 { Unit# ipv5 ->
                                          ipv5 }) of wild1 {
                                    Data.Either.Left y
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ b
                                              ipv2
                                              ww4
                                              y
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.or# ww5 ww3)
                                         ww6
                                         ww7
                                         s' }
                                    Data.Either.Right z
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv4
                                              ww6
                                              z
                                              w1 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww3 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww2 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         ww4
                                         ww5
                                         (GHC.Prim.+# ww6 1#)
                                         (GHC.Prim.or# ww7 ww3)
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.freezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ b
                                         ipv2
                                         0#
                                         (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww5))
                                         w1 of ds2 { (#,#) ipv5 ipv6 ->
                                  case GHC.Prim.freezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ c
                                         ipv4
                                         0#
                                         (GHC.Prim.word2Int# (GHC.Prim.popCnt# ww7))
                                         ipv5 of ds3 { (#,#) ipv7 ipv8 ->
                                  (# ipv7,
                                     (Data.Trie.ArrayMapped.SparseArray.SA @ b ww5 ipv6,
                                      Data.Trie.ArrayMapped.SparseArray.SA @ c ww7 ipv8) #) } } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww
                              (GHC.Prim.int2Word# (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww))))
                           0#
                           0##
                           0#
                           0##
                           ipv3 } }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
6cefdc1c5f306023c6ca8d2b432a578d
  $wpartitionMapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key
     -> a -> Data.Either.Either b c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
        Data.Trie.ArrayMapped.SparseArray.SparseArray c)
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            @ c
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key
                                  -> a -> Data.Either.Either b c)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          let {
                            ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
                                    Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ b
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                                         eta of ds { (#,#) ipv1 ipv2 ->
                                  case GHC.Prim.newArray#
                                         @ c
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                         ipv1 of ds1 { (#,#) ipv3 ipv4 ->
                                  letrec {
                                    go :: GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> Data.Trie.ArrayMapped.SparseArray.Index
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
                                                Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                      {- Arity: 6 -}
                                    = \ (i :: GHC.Types.Int)
                                        (bi :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (j :: Data.Trie.ArrayMapped.SparseArray.Index)
                                        (q :: Data.Trie.ArrayMapped.SparseArray.Bitmap)
                                        (k :: GHC.Types.Int)
                                        (r :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case i of i1 { GHC.Types.I# ipv5 ->
                                      case bi of bi1 { GHC.Types.W# ipv6 ->
                                      case j of j1 { GHC.Types.I# ipv7 ->
                                      case q of q1 { GHC.Types.W# ipv8 ->
                                      case k of k1 { GHC.Types.I# ipv9 ->
                                      case r of r1 { GHC.Types.W# ipv10 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.>=# ipv5 ipv) of wild {
                                        GHC.Types.False
                                        -> case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                        -> GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld
                                                                                                                        -> (# GHC.Prim.State#
                                                                                                                                GHC.Prim.RealWorld,
                                                                                                                              GHC.Prim.Int# #)}
                                                          (GHC.Prim.narrow32Int#
                                                             (GHC.Prim.word2Int# ipv6))
                                                          GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                                                   GHC.Word.W8#
                                                     (GHC.Prim.narrow8Word#
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.narrow32Int# ds3))) })
                                                  (case GHC.Prim.indexArray#
                                                          @ a
                                                          ww1
                                                          ipv5 of ds2 { Unit# ipv11 ->
                                                   ipv11 }) of wild1 {
                                             Data.Either.Left y
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ b
                                                        ipv2
                                                        ipv7
                                                        y
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv6
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv8 ipv6))
                                                    k1
                                                    r1)
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          b,
                                                        Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          c)>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              b,
                                                            Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              c)>_R))
                                             Data.Either.Right z
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ c
                                                        ipv4
                                                        ipv9
                                                        z
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv6
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    j1
                                                    q1
                                                    (GHC.Types.I# (GHC.Prim.+# ipv9 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv10 ipv6)))
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          b,
                                                        Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          c)>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              b,
                                                            Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              c)>_R)) }
                                        GHC.Types.True
                                        -> (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                            case GHC.Prim.freezeArray#
                                                   @ GHC.Prim.RealWorld
                                                   @ b
                                                   ipv2
                                                   0#
                                                   (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv8))
                                                   s1 of ds2 { (#,#) ipv11 ipv12 ->
                                            case GHC.Prim.freezeArray#
                                                   @ GHC.Prim.RealWorld
                                                   @ c
                                                   ipv4
                                                   0#
                                                   (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv10))
                                                   ipv11 of ds3 { (#,#) ipv13 ipv14 ->
                                            (# ipv13,
                                               (Data.Trie.ArrayMapped.SparseArray.SA @ b ipv8 ipv12,
                                                Data.Trie.ArrayMapped.SparseArray.SA
                                                  @ c
                                                  ipv10
                                                  ipv14) #) } })
                                             `cast`
                                           (Sym (GHC.ST.N:ST[0]
                                                     <GHC.Prim.RealWorld>_N
                                                     <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                         b,
                                                       Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                         c)>_R)) } } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ww
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##)
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <(Data.Trie.ArrayMapped.SparseArray.SparseArray b,
                                         Data.Trie.ArrayMapped.SparseArray.SparseArray c)>_R)
                                    ipv3 } }) of ds1 { (#,#) ipv1 ipv2 ->
                          ipv2 }) -}
62f399e132152f83b1f09c57db93d289
  $wpartitionWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
        Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 3, Strictness: <L,C(C1(U))><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a) ->
                          let {
                            wild :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                            = Data.Trie.ArrayMapped.SparseArray.SA @ a ww ww1
                          } in
                          let {
                            ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
                                    Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ a
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                         eta of ds { (#,#) ipv1 ipv2 ->
                                  case GHC.Prim.newArray#
                                         @ a
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                         ipv1 of ds1 { (#,#) ipv3 ipv4 ->
                                  letrec {
                                    go :: GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
                                                Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                      {- Arity: 6 -}
                                    = \ (i :: GHC.Types.Int)
                                        (bi :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (j :: GHC.Types.Int)
                                        (q :: Data.Trie.ArrayMapped.SparseArray.Bitmap)
                                        (k :: GHC.Types.Int)
                                        (r :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case i of i1 { GHC.Types.I# ipv5 ->
                                      case bi of bi1 { GHC.Types.W# ipv6 ->
                                      case j of j1 { GHC.Types.I# ipv7 ->
                                      case q of q1 { GHC.Types.W# ipv8 ->
                                      case k of k1 { GHC.Types.I# ipv9 ->
                                      case r of r1 { GHC.Types.W# ipv10 ->
                                      let {
                                        x :: a
                                        = case GHC.Prim.indexArray#
                                                 @ a
                                                 ww1
                                                 ipv5 of ds2 { Unit# ipv11 ->
                                          ipv11 }
                                      } in
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.>=# ipv5 ipv) of wild1 {
                                        GHC.Types.False
                                        -> case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                        -> GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld
                                                                                                                        -> (# GHC.Prim.State#
                                                                                                                                GHC.Prim.RealWorld,
                                                                                                                              GHC.Prim.Int# #)}
                                                          (GHC.Prim.narrow32Int#
                                                             (GHC.Prim.word2Int# ipv6))
                                                          GHC.Prim.realWorld# of wild2 { (#,#) ds2 ds3 ->
                                                   GHC.Word.W8#
                                                     (GHC.Prim.narrow8Word#
                                                        (GHC.Prim.int2Word#
                                                           (GHC.Prim.narrow32Int# ds3))) })
                                                  x of wild2 {
                                             GHC.Types.False
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ a
                                                        ipv4
                                                        ipv9
                                                        x
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv6
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    j1
                                                    q1
                                                    (GHC.Types.I# (GHC.Prim.+# ipv9 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv10 ipv6)))
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a,
                                                        Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a)>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a,
                                                            Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a)>_R))
                                             GHC.Types.True
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.writeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ a
                                                        ipv2
                                                        ipv7
                                                        x
                                                        s1 of s' { DEFAULT ->
                                                 (go
                                                    (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                    (let {
                                                       p :: GHC.Prim.Word#
                                                       = GHC.Prim.and#
                                                           ww
                                                           (GHC.Prim.int2Word#
                                                              (GHC.Prim.negateInt#
                                                                 (GHC.Prim.word2Int#
                                                                    (GHC.Prim.uncheckedShiftL#
                                                                       ipv6
                                                                       1#))))
                                                     } in
                                                     GHC.Types.W#
                                                       (GHC.Prim.and#
                                                          p
                                                          (GHC.Prim.int2Word#
                                                             (GHC.Prim.negateInt#
                                                                (GHC.Prim.word2Int# p)))))
                                                    (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                    (GHC.Types.W# (GHC.Prim.or# ipv8 ipv6))
                                                    k1
                                                    r1)
                                                   `cast`
                                                 (GHC.ST.N:ST[0]
                                                      <GHC.Prim.RealWorld>_N
                                                      <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a,
                                                        Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a)>_R)
                                                   s' })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a,
                                                            Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a)>_R)) }
                                        GHC.Types.True
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.==# ipv5 ipv7) of wild2 {
                                             GHC.Types.False
                                             -> case GHC.Prim.tagToEnum#
                                                       @ GHC.Types.Bool
                                                       (GHC.Prim.==# ipv5 ipv9) of wild3 {
                                                  GHC.Types.False
                                                  -> (\ (s1 :: GHC.Prim.State#
                                                                 GHC.Prim.RealWorld)[OneShot] ->
                                                      case GHC.Prim.freezeArray#
                                                             @ GHC.Prim.RealWorld
                                                             @ a
                                                             ipv2
                                                             0#
                                                             (GHC.Prim.word2Int#
                                                                (GHC.Prim.popCnt# ipv8))
                                                             s1 of ds2 { (#,#) ipv11 ipv12 ->
                                                      case GHC.Prim.freezeArray#
                                                             @ GHC.Prim.RealWorld
                                                             @ a
                                                             ipv4
                                                             0#
                                                             (GHC.Prim.word2Int#
                                                                (GHC.Prim.popCnt# ipv10))
                                                             ipv11 of ds3 { (#,#) ipv13 ipv14 ->
                                                      (# ipv13,
                                                         (Data.Trie.ArrayMapped.SparseArray.SA
                                                            @ a
                                                            ipv8
                                                            ipv12,
                                                          Data.Trie.ArrayMapped.SparseArray.SA
                                                            @ a
                                                            ipv10
                                                            ipv14) #) } })
                                                       `cast`
                                                     (Sym (GHC.ST.N:ST[0]
                                                               <GHC.Prim.RealWorld>_N
                                                               <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   a,
                                                                 Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   a)>_R))
                                                  GHC.Types.True
                                                  -> (\ (s1 :: GHC.Prim.State#
                                                                 GHC.Prim.RealWorld)[OneShot] ->
                                                      (# s1,
                                                         (Data.Trie.ArrayMapped.SparseArray.empty
                                                            @ a,
                                                          wild) #))
                                                       `cast`
                                                     (Sym (GHC.ST.N:ST[0]
                                                               <GHC.Prim.RealWorld>_N
                                                               <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   a,
                                                                 Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   a)>_R)) }
                                             GHC.Types.True
                                             -> (\ (s1 :: GHC.Prim.State#
                                                            GHC.Prim.RealWorld)[OneShot] ->
                                                 (# s1,
                                                    (wild,
                                                     Data.Trie.ArrayMapped.SparseArray.empty
                                                       @ a) #))
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <(Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a,
                                                            Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              a)>_R)) } } } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ww
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##)
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <(Data.Trie.ArrayMapped.SparseArray.SparseArray a,
                                         Data.Trie.ArrayMapped.SparseArray.SparseArray a)>_R)
                                    ipv3 } }) of ds1 { (#,#) ipv1 ipv2 ->
                          ipv2 }) -}
a8e05ff32b2fcae6931b35cdb4f9b3c4
  $wrzipFilter_ ::
    (a -> b -> GHC.Base.Maybe c)
    -> (b -> GHC.Base.Maybe c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 6, Strictness: <L,C(C1(U))><L,C(U)><L,U><S,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ b
                            @ c
                            (w :: a -> b -> GHC.Base.Maybe c)
                            (w1 :: b -> GHC.Base.Maybe c)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a)
                            (ww2 :: GHC.Prim.Word#)
                            (ww3 :: GHC.Prim.Array# b) ->
                          let {
                            ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww2)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ c
                                         @ GHC.Prim.RealWorld
                                         ipv
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                         eta of ds { (#,#) ipv1 ipv2 ->
                                  letrec {
                                    go :: Data.Trie.ArrayMapped.SparseArray.Index
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> GHC.Types.Int
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                      {- Arity: 5 -}
                                    = \ (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                                        (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (j :: GHC.Types.Int)
                                        (k :: GHC.Types.Int)
                                        (r :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case i of i1 { GHC.Types.I# ipv3 ->
                                      case b1 of b2 { GHC.Types.W# ipv4 ->
                                      case j of j1 { GHC.Types.I# ipv5 ->
                                      case k of k1 { GHC.Types.I# ipv6 ->
                                      case r of r1 { GHC.Types.W# ipv7 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.>=# ipv5 ipv) of wild {
                                        GHC.Types.False
                                        -> case GHC.Prim.and# ww ipv4 of wild1 {
                                             DEFAULT
                                             -> case w (case GHC.Prim.indexArray#
                                                               @ a
                                                               ww1
                                                               ipv3 of ds1 { Unit# ipv8 ->
                                                        ipv8 })
                                                       (case GHC.Prim.indexArray#
                                                               @ b
                                                               ww3
                                                               ipv5 of ds1 { Unit# ipv8 ->
                                                        ipv8 }) of wild2 {
                                                  GHC.Base.Nothing
                                                  -> go
                                                       (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                       (let {
                                                          p :: GHC.Prim.Word#
                                                          = GHC.Prim.and#
                                                              ww2
                                                              (GHC.Prim.int2Word#
                                                                 (GHC.Prim.negateInt#
                                                                    (GHC.Prim.word2Int#
                                                                       (GHC.Prim.uncheckedShiftL#
                                                                          ipv4
                                                                          1#))))
                                                        } in
                                                        GHC.Types.W#
                                                          (GHC.Prim.and#
                                                             p
                                                             (GHC.Prim.int2Word#
                                                                (GHC.Prim.negateInt#
                                                                   (GHC.Prim.word2Int# p)))))
                                                       (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                       k1
                                                       r1
                                                  GHC.Base.Just z
                                                  -> (\ (s1 :: GHC.Prim.State#
                                                                 GHC.Prim.RealWorld)[OneShot] ->
                                                      case GHC.Prim.writeArray#
                                                             @ GHC.Prim.RealWorld
                                                             @ c
                                                             ipv2
                                                             ipv6
                                                             z
                                                             s1 of s' { DEFAULT ->
                                                      (go
                                                         (GHC.Types.I# (GHC.Prim.+# ipv3 1#))
                                                         (let {
                                                            p :: GHC.Prim.Word#
                                                            = GHC.Prim.and#
                                                                ww2
                                                                (GHC.Prim.int2Word#
                                                                   (GHC.Prim.negateInt#
                                                                      (GHC.Prim.word2Int#
                                                                         (GHC.Prim.uncheckedShiftL#
                                                                            ipv4
                                                                            1#))))
                                                          } in
                                                          GHC.Types.W#
                                                            (GHC.Prim.and#
                                                               p
                                                               (GHC.Prim.int2Word#
                                                                  (GHC.Prim.negateInt#
                                                                     (GHC.Prim.word2Int# p)))))
                                                         (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                         (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                         (GHC.Types.W# (GHC.Prim.or# ipv7 ipv4)))
                                                        `cast`
                                                      (GHC.ST.N:ST[0]
                                                           <GHC.Prim.RealWorld>_N
                                                           <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              c>_R)
                                                        s' })
                                                       `cast`
                                                     (Sym (GHC.ST.N:ST[0]
                                                               <GHC.Prim.RealWorld>_N
                                                               <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                  c>_R)) }
                                             0##
                                             -> case w1
                                                       (case GHC.Prim.indexArray#
                                                               @ b
                                                               ww3
                                                               ipv5 of ds1 { Unit# ipv8 ->
                                                        ipv8 }) of wild2 {
                                                  GHC.Base.Nothing
                                                  -> go
                                                       i1
                                                       (let {
                                                          p :: GHC.Prim.Word#
                                                          = GHC.Prim.and#
                                                              ww2
                                                              (GHC.Prim.int2Word#
                                                                 (GHC.Prim.negateInt#
                                                                    (GHC.Prim.word2Int#
                                                                       (GHC.Prim.uncheckedShiftL#
                                                                          ipv4
                                                                          1#))))
                                                        } in
                                                        GHC.Types.W#
                                                          (GHC.Prim.and#
                                                             p
                                                             (GHC.Prim.int2Word#
                                                                (GHC.Prim.negateInt#
                                                                   (GHC.Prim.word2Int# p)))))
                                                       (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                       k1
                                                       r1
                                                  GHC.Base.Just z
                                                  -> (\ (s1 :: GHC.Prim.State#
                                                                 GHC.Prim.RealWorld)[OneShot] ->
                                                      case GHC.Prim.writeArray#
                                                             @ GHC.Prim.RealWorld
                                                             @ c
                                                             ipv2
                                                             ipv6
                                                             z
                                                             s1 of s' { DEFAULT ->
                                                      (go
                                                         i1
                                                         (let {
                                                            p :: GHC.Prim.Word#
                                                            = GHC.Prim.and#
                                                                ww2
                                                                (GHC.Prim.int2Word#
                                                                   (GHC.Prim.negateInt#
                                                                      (GHC.Prim.word2Int#
                                                                         (GHC.Prim.uncheckedShiftL#
                                                                            ipv4
                                                                            1#))))
                                                          } in
                                                          GHC.Types.W#
                                                            (GHC.Prim.and#
                                                               p
                                                               (GHC.Prim.int2Word#
                                                                  (GHC.Prim.negateInt#
                                                                     (GHC.Prim.word2Int# p)))))
                                                         (GHC.Types.I# (GHC.Prim.+# ipv5 1#))
                                                         (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                         (GHC.Types.W# (GHC.Prim.or# ipv7 ipv4)))
                                                        `cast`
                                                      (GHC.ST.N:ST[0]
                                                           <GHC.Prim.RealWorld>_N
                                                           <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                              c>_R)
                                                        s' })
                                                       `cast`
                                                     (Sym (GHC.ST.N:ST[0]
                                                               <GHC.Prim.RealWorld>_N
                                                               <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                  c>_R)) } }
                                        GHC.Types.True
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.==# ipv5 ipv6) of wild1 {
                                             GHC.Types.False
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.freezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ c
                                                        ipv2
                                                        0#
                                                        (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv7))
                                                        s of ds1 { (#,#) ipv8 ipv9 ->
                                                 (# ipv8,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ c
                                                      ipv7
                                                      ipv9 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             c>_R))
                                             GHC.Types.True
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.unsafeFreezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ c
                                                        ipv2
                                                        s of ds1 { (#,#) ipv8 ipv9 ->
                                                 (# ipv8,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ c
                                                      ipv7
                                                      ipv9 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             c>_R)) } } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ww2
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww2)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <Data.Trie.ArrayMapped.SparseArray.SparseArray c>_R)
                                    ipv1 }) of ds1 { (#,#) ipv1 ipv2 ->
                          ipv2 }) -}
a416c5c97806be1ba0c7fadb846c7577
  $wrzipWith'_ ::
    (a -> b -> c)
    -> (b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 6, Strictness: <L,C(C1(U))><L,C(U)><L,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww2)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                           = \ (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 ipv) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.and# ww ww5 of wild1 {
                                    DEFAULT
                                    -> case w (case GHC.Prim.indexArray#
                                                      @ a
                                                      ww1
                                                      ww4 of ds1 { Unit# ipv3 ->
                                               ipv3 })
                                              (case GHC.Prim.indexArray#
                                                      @ b
                                                      ww3
                                                      ww6 of ds1 { Unit# ipv3 ->
                                               ipv3 }) of x1 { DEFAULT ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              x1
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } }
                                    0##
                                    -> case w1
                                              (case GHC.Prim.indexArray#
                                                      @ b
                                                      ww3
                                                      ww6 of ds1 { Unit# ipv3 ->
                                               ipv3 }) of x1 { DEFAULT ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              x1
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         ww4
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ c
                                         ipv2
                                         w2 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ c ww2 ipv4 #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww2
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww2))))
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
ee3e2b86266316dd00c30c2494d53d65
  $wrzipWithKey'_ ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
    -> (Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 6,
     Strictness: <L,C(C1(C1(U)))><L,C(C1(U))><L,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww2)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                           = \ (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 ipv) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.and# ww ww5 of wild1 {
                                    DEFAULT
                                    -> case w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                    -> GHC.Prim.State#
                                                                                                                         GHC.Prim.RealWorld
                                                                                                                    -> (# GHC.Prim.State#
                                                                                                                            GHC.Prim.RealWorld,
                                                                                                                          GHC.Prim.Int# #)}
                                                      (GHC.Prim.narrow32Int#
                                                         (GHC.Prim.word2Int# ww5))
                                                      GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                                               GHC.Word.W8#
                                                 (GHC.Prim.narrow8Word#
                                                    (GHC.Prim.int2Word#
                                                       (GHC.Prim.narrow32Int# ds2))) })
                                              (case GHC.Prim.indexArray#
                                                      @ a
                                                      ww1
                                                      ww4 of ds1 { Unit# ipv3 ->
                                               ipv3 })
                                              (case GHC.Prim.indexArray#
                                                      @ b
                                                      ww3
                                                      ww6 of ds1 { Unit# ipv3 ->
                                               ipv3 }) of x1 { DEFAULT ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              x1
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } }
                                    0##
                                    -> case w1
                                              (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                    -> GHC.Prim.State#
                                                                                                                         GHC.Prim.RealWorld
                                                                                                                    -> (# GHC.Prim.State#
                                                                                                                            GHC.Prim.RealWorld,
                                                                                                                          GHC.Prim.Int# #)}
                                                      (GHC.Prim.narrow32Int#
                                                         (GHC.Prim.word2Int# ww5))
                                                      GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                                               GHC.Word.W8#
                                                 (GHC.Prim.narrow8Word#
                                                    (GHC.Prim.int2Word#
                                                       (GHC.Prim.narrow32Int# ds2))) })
                                              (case GHC.Prim.indexArray#
                                                      @ b
                                                      ww3
                                                      ww6 of ds1 { Unit# ipv3 ->
                                               ipv3 }) of x1 { DEFAULT ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              x1
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         ww4
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ c
                                         ipv2
                                         w2 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ c ww2 ipv4 #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww2
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww2))))
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
d8bdc10a3071c8e936a2013476e35eda
  $wrzipWithKey_ ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
    -> (Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 6,
     Strictness: <L,C(C1(C1(U)))><L,C(C1(U))><L,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww2)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                           = \ (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 ipv) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.and# ww ww5 of wild1 {
                                    DEFAULT
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              (w (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                       -> GHC.Prim.State#
                                                                                                                            GHC.Prim.RealWorld
                                                                                                                       -> (# GHC.Prim.State#
                                                                                                                               GHC.Prim.RealWorld,
                                                                                                                             GHC.Prim.Int# #)}
                                                         (GHC.Prim.narrow32Int#
                                                            (GHC.Prim.word2Int# ww5))
                                                         GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                                                  GHC.Word.W8#
                                                    (GHC.Prim.narrow8Word#
                                                       (GHC.Prim.int2Word#
                                                          (GHC.Prim.narrow32Int# ds2))) })
                                                 (case GHC.Prim.indexArray#
                                                         @ a
                                                         ww1
                                                         ww4 of ds1 { Unit# ipv3 ->
                                                  ipv3 })
                                                 (case GHC.Prim.indexArray#
                                                         @ b
                                                         ww3
                                                         ww6 of ds1 { Unit# ipv3 ->
                                                  ipv3 }))
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' }
                                    0##
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              (w1
                                                 (case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                                                       -> GHC.Prim.State#
                                                                                                                            GHC.Prim.RealWorld
                                                                                                                       -> (# GHC.Prim.State#
                                                                                                                               GHC.Prim.RealWorld,
                                                                                                                             GHC.Prim.Int# #)}
                                                         (GHC.Prim.narrow32Int#
                                                            (GHC.Prim.word2Int# ww5))
                                                         GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                                                  GHC.Word.W8#
                                                    (GHC.Prim.narrow8Word#
                                                       (GHC.Prim.int2Word#
                                                          (GHC.Prim.narrow32Int# ds2))) })
                                                 (case GHC.Prim.indexArray#
                                                         @ b
                                                         ww3
                                                         ww6 of ds1 { Unit# ipv3 ->
                                                  ipv3 }))
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         ww4
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ c
                                         ipv2
                                         w2 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ c ww2 ipv4 #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww2
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww2))))
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
55914ff12709b1ae42ebae37c7d3412c
  $wrzipWith_ ::
    (a -> b -> c)
    -> (b -> c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 6, Strictness: <L,C(C1(U))><L,C(U)><L,U><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: b -> c)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# b) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww2)
                         } in
                         case GHC.Prim.newArray#
                                @ c
                                @ GHC.Prim.RealWorld
                                ipv
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                eta of ds { (#,#) ipv1 ipv2 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Int#
                                    -> GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray c #)
                             {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                           = \ (ww4 :: GHC.Prim.Int#)
                               (ww5 :: GHC.Prim.Word#)
                               (ww6 :: GHC.Prim.Int#)
                               (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 ipv) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.and# ww ww5 of wild1 {
                                    DEFAULT
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              (w (case GHC.Prim.indexArray#
                                                         @ a
                                                         ww1
                                                         ww4 of ds1 { Unit# ipv3 ->
                                                  ipv3 })
                                                 (case GHC.Prim.indexArray#
                                                         @ b
                                                         ww3
                                                         ww6 of ds1 { Unit# ipv3 ->
                                                  ipv3 }))
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.+# ww4 1#)
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' }
                                    0##
                                    -> case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ c
                                              ipv2
                                              ww6
                                              (w1
                                                 (case GHC.Prim.indexArray#
                                                         @ b
                                                         ww3
                                                         ww6 of ds1 { Unit# ipv3 ->
                                                  ipv3 }))
                                              w2 of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ww2
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww5 1#))))
                                       } in
                                       $wgo2
                                         ww4
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         (GHC.Prim.+# ww6 1#)
                                         s' } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ c
                                         ipv2
                                         w2 of ds1 { (#,#) ipv3 ipv4 ->
                                  (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ c ww2 ipv4 #) } }
                         } in
                         $wgo2
                           0#
                           (GHC.Prim.and#
                              ww2
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ww2))))
                           0#
                           ipv1 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
5e3811f92ce8f7a9e6d0ce8e79a2d596
  $wtraverseST ::
    (a -> GHC.ST.ST s b)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
  {- Arity: 4, Strictness: <L,C(C1(U(U,U)))><S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ s
                   @ b
                   (w :: a -> GHC.ST.ST s b)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (w1 :: GHC.Prim.State# s)[OneShot] ->
                 let {
                   ipv :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ww)
                 } in
                 case GHC.Prim.newArray#
                        @ b
                        @ s
                        ipv
                        (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ b)
                        w1 of ds { (#,#) ipv1 ipv2 ->
                 letrec {
                   $wgo2 :: GHC.Prim.Word#
                            -> GHC.Prim.Array# a
                            -> GHC.Prim.Int#
                            -> GHC.Prim.MutableArray# s b
                            -> GHC.Prim.Int#
                            -> GHC.Prim.State# s
                            -> (# GHC.Prim.State# s,
                                  Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
                     {- Arity: 6, Strictness: <L,U><L,U><S,U><S,U><S,U><S,U>,
                        Inline: [0] -}
                   = \ (ww2 :: GHC.Prim.Word#)
                       (w2 :: GHC.Prim.Array# a)
                       (ww3 :: GHC.Prim.Int#)
                       (w3 :: GHC.Prim.MutableArray# s b)
                       (ww4 :: GHC.Prim.Int#)
                       (w4 :: GHC.Prim.State# s)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# ww4 ww3) of wild {
                       GHC.Types.False
                       -> case GHC.Prim.unsafeFreezeArray#
                                 @ s
                                 @ b
                                 w3
                                 w4 of ds1 { (#,#) ipv3 ipv4 ->
                          (# ipv3, Data.Trie.ArrayMapped.SparseArray.SA @ b ww2 ipv4 #) }
                       GHC.Types.True
                       -> case (w (case GHC.Prim.indexArray#
                                          @ a
                                          w2
                                          ww4 of ds1 { Unit# ipv3 ->
                                   ipv3 }))
                                 `cast`
                               (GHC.ST.N:ST[0] <s>_N <b>_R)
                                 w4 of ds1 { (#,#) ipv3 ipv4 ->
                          case GHC.Prim.writeArray#
                                 @ s
                                 @ b
                                 w3
                                 ww4
                                 ipv4
                                 ipv3 of s' { DEFAULT ->
                          $wgo2 ww2 w2 ww3 w3 (GHC.Prim.+# ww4 1#) s' } } }
                 } in
                 $wgo2 ww ww1 ipv ipv2 0# ipv1 }) -}
8c50259f2a8f8d580282689562722640
  $wunionFilterWith_ ::
    (a -> GHC.Base.Maybe c)
    -> (a -> b -> GHC.Base.Maybe c)
    -> (b -> GHC.Base.Maybe c)
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 7,
     Strictness: <L,C(U)><L,C(C1(U))><L,C(U)><S,U><S,U><S,U><S,U>,
     Inline: INLINABLE[0],
     Unfolding: <stable> (\ @ a
                            @ c
                            @ b
                            (w :: a -> GHC.Base.Maybe c)
                            (w1 :: a -> b -> GHC.Base.Maybe c)
                            (w2 :: b -> GHC.Base.Maybe c)
                            (ww :: GHC.Prim.Word#)
                            (ww1 :: GHC.Prim.Array# a)
                            (ww2 :: GHC.Prim.Word#)
                            (ww3 :: GHC.Prim.Array# b) ->
                          let {
                            ipv :: GHC.Prim.Word# = GHC.Prim.or# ww ww2
                          } in
                          let {
                            ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                          } in
                          case GHC.Magic.runRW#
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                 (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newArray#
                                         @ c
                                         @ GHC.Prim.RealWorld
                                         ipv1
                                         (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ c)
                                         eta of ds { (#,#) ipv2 ipv3 ->
                                  letrec {
                                    go :: Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> Data.Trie.ArrayMapped.SparseArray.OneBit
                                          -> Data.Trie.ArrayMapped.SparseArray.Index
                                          -> GHC.Types.Int
                                          -> GHC.Types.Int
                                          -> Data.Trie.ArrayMapped.SparseArray.Bitmap
                                          -> GHC.ST.ST
                                               GHC.Prim.RealWorld
                                               (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                      {- Arity: 6 -}
                                    = \ (r0 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                                        (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                                        (j :: GHC.Types.Int)
                                        (k :: GHC.Types.Int)
                                        (r :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                                      case r0 of r1 { GHC.Types.W# ipv4 ->
                                      case b1 of b2 { GHC.Types.W# ipv5 ->
                                      case i of i1 { GHC.Types.I# ipv6 ->
                                      case j of j1 { GHC.Types.I# ipv7 ->
                                      case k of k1 { GHC.Types.I# ipv8 ->
                                      case r of r2 { GHC.Types.W# ipv9 ->
                                      case ipv4 of wild {
                                        DEFAULT
                                        -> case GHC.Prim.and# ww ipv5 of wild1 {
                                             DEFAULT
                                             -> case GHC.Prim.and# ww2 ipv5 of wild2 {
                                                  DEFAULT
                                                  -> case w1
                                                            (case GHC.Prim.indexArray#
                                                                    @ a
                                                                    ww1
                                                                    ipv6 of ds1 { Unit# ipv10 ->
                                                             ipv10 })
                                                            (case GHC.Prim.indexArray#
                                                                    @ b
                                                                    ww3
                                                                    ipv7 of ds1 { Unit# ipv10 ->
                                                             ipv10 }) of wild3 {
                                                       GHC.Base.Nothing
                                                       -> go
                                                            (GHC.Types.W# (GHC.Prim.xor# wild ipv5))
                                                            (let {
                                                               p :: GHC.Prim.Word#
                                                               = GHC.Prim.and#
                                                                   wild
                                                                   (GHC.Prim.int2Word#
                                                                      (GHC.Prim.negateInt#
                                                                         (GHC.Prim.word2Int#
                                                                            (GHC.Prim.uncheckedShiftL#
                                                                               ipv5
                                                                               1#))))
                                                             } in
                                                             GHC.Types.W#
                                                               (GHC.Prim.and#
                                                                  p
                                                                  (GHC.Prim.int2Word#
                                                                     (GHC.Prim.negateInt#
                                                                        (GHC.Prim.word2Int# p)))))
                                                            (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                            (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                            k1
                                                            r2
                                                       GHC.Base.Just z
                                                       -> (\ (s1 :: GHC.Prim.State#
                                                                      GHC.Prim.RealWorld)[OneShot] ->
                                                           case GHC.Prim.writeArray#
                                                                  @ GHC.Prim.RealWorld
                                                                  @ c
                                                                  ipv3
                                                                  ipv8
                                                                  z
                                                                  s1 of s' { DEFAULT ->
                                                           (go
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.xor# wild ipv5))
                                                              (let {
                                                                 p :: GHC.Prim.Word#
                                                                 = GHC.Prim.and#
                                                                     wild
                                                                     (GHC.Prim.int2Word#
                                                                        (GHC.Prim.negateInt#
                                                                           (GHC.Prim.word2Int#
                                                                              (GHC.Prim.uncheckedShiftL#
                                                                                 ipv5
                                                                                 1#))))
                                                               } in
                                                               GHC.Types.W#
                                                                 (GHC.Prim.and#
                                                                    p
                                                                    (GHC.Prim.int2Word#
                                                                       (GHC.Prim.negateInt#
                                                                          (GHC.Prim.word2Int# p)))))
                                                              (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                              (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                              (GHC.Types.I# (GHC.Prim.+# ipv8 1#))
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.or# ipv9 ipv5)))
                                                             `cast`
                                                           (GHC.ST.N:ST[0]
                                                                <GHC.Prim.RealWorld>_N
                                                                <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   c>_R)
                                                             s' })
                                                            `cast`
                                                          (Sym (GHC.ST.N:ST[0]
                                                                    <GHC.Prim.RealWorld>_N
                                                                    <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                       c>_R)) }
                                                  0##
                                                  -> case w (case GHC.Prim.indexArray#
                                                                    @ a
                                                                    ww1
                                                                    ipv6 of ds1 { Unit# ipv10 ->
                                                             ipv10 }) of wild3 {
                                                       GHC.Base.Nothing
                                                       -> go
                                                            (GHC.Types.W# (GHC.Prim.xor# wild ipv5))
                                                            (let {
                                                               p :: GHC.Prim.Word#
                                                               = GHC.Prim.and#
                                                                   wild
                                                                   (GHC.Prim.int2Word#
                                                                      (GHC.Prim.negateInt#
                                                                         (GHC.Prim.word2Int#
                                                                            (GHC.Prim.uncheckedShiftL#
                                                                               ipv5
                                                                               1#))))
                                                             } in
                                                             GHC.Types.W#
                                                               (GHC.Prim.and#
                                                                  p
                                                                  (GHC.Prim.int2Word#
                                                                     (GHC.Prim.negateInt#
                                                                        (GHC.Prim.word2Int# p)))))
                                                            (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                            j1
                                                            k1
                                                            r2
                                                       GHC.Base.Just z
                                                       -> (\ (s1 :: GHC.Prim.State#
                                                                      GHC.Prim.RealWorld)[OneShot] ->
                                                           case GHC.Prim.writeArray#
                                                                  @ GHC.Prim.RealWorld
                                                                  @ c
                                                                  ipv3
                                                                  ipv8
                                                                  z
                                                                  s1 of s' { DEFAULT ->
                                                           (go
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.xor# wild ipv5))
                                                              (let {
                                                                 p :: GHC.Prim.Word#
                                                                 = GHC.Prim.and#
                                                                     wild
                                                                     (GHC.Prim.int2Word#
                                                                        (GHC.Prim.negateInt#
                                                                           (GHC.Prim.word2Int#
                                                                              (GHC.Prim.uncheckedShiftL#
                                                                                 ipv5
                                                                                 1#))))
                                                               } in
                                                               GHC.Types.W#
                                                                 (GHC.Prim.and#
                                                                    p
                                                                    (GHC.Prim.int2Word#
                                                                       (GHC.Prim.negateInt#
                                                                          (GHC.Prim.word2Int# p)))))
                                                              (GHC.Types.I# (GHC.Prim.+# ipv6 1#))
                                                              j1
                                                              (GHC.Types.I# (GHC.Prim.+# ipv8 1#))
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.or# ipv9 ipv5)))
                                                             `cast`
                                                           (GHC.ST.N:ST[0]
                                                                <GHC.Prim.RealWorld>_N
                                                                <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   c>_R)
                                                             s' })
                                                            `cast`
                                                          (Sym (GHC.ST.N:ST[0]
                                                                    <GHC.Prim.RealWorld>_N
                                                                    <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                       c>_R)) } }
                                             0##
                                             -> case GHC.Prim.and# ww2 ipv5 of wild2 {
                                                  DEFAULT
                                                  -> case w2
                                                            (case GHC.Prim.indexArray#
                                                                    @ b
                                                                    ww3
                                                                    ipv7 of ds1 { Unit# ipv10 ->
                                                             ipv10 }) of wild3 {
                                                       GHC.Base.Nothing
                                                       -> go
                                                            (GHC.Types.W# (GHC.Prim.xor# wild ipv5))
                                                            (let {
                                                               p :: GHC.Prim.Word#
                                                               = GHC.Prim.and#
                                                                   wild
                                                                   (GHC.Prim.int2Word#
                                                                      (GHC.Prim.negateInt#
                                                                         (GHC.Prim.word2Int#
                                                                            (GHC.Prim.uncheckedShiftL#
                                                                               ipv5
                                                                               1#))))
                                                             } in
                                                             GHC.Types.W#
                                                               (GHC.Prim.and#
                                                                  p
                                                                  (GHC.Prim.int2Word#
                                                                     (GHC.Prim.negateInt#
                                                                        (GHC.Prim.word2Int# p)))))
                                                            i1
                                                            (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                            k1
                                                            r2
                                                       GHC.Base.Just z
                                                       -> (\ (s1 :: GHC.Prim.State#
                                                                      GHC.Prim.RealWorld)[OneShot] ->
                                                           case GHC.Prim.writeArray#
                                                                  @ GHC.Prim.RealWorld
                                                                  @ c
                                                                  ipv3
                                                                  ipv8
                                                                  z
                                                                  s1 of s' { DEFAULT ->
                                                           (go
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.xor# wild ipv5))
                                                              (let {
                                                                 p :: GHC.Prim.Word#
                                                                 = GHC.Prim.and#
                                                                     wild
                                                                     (GHC.Prim.int2Word#
                                                                        (GHC.Prim.negateInt#
                                                                           (GHC.Prim.word2Int#
                                                                              (GHC.Prim.uncheckedShiftL#
                                                                                 ipv5
                                                                                 1#))))
                                                               } in
                                                               GHC.Types.W#
                                                                 (GHC.Prim.and#
                                                                    p
                                                                    (GHC.Prim.int2Word#
                                                                       (GHC.Prim.negateInt#
                                                                          (GHC.Prim.word2Int# p)))))
                                                              i1
                                                              (GHC.Types.I# (GHC.Prim.+# ipv7 1#))
                                                              (GHC.Types.I# (GHC.Prim.+# ipv8 1#))
                                                              (GHC.Types.W#
                                                                 (GHC.Prim.or# ipv9 ipv5)))
                                                             `cast`
                                                           (GHC.ST.N:ST[0]
                                                                <GHC.Prim.RealWorld>_N
                                                                <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                   c>_R)
                                                             s' })
                                                            `cast`
                                                          (Sym (GHC.ST.N:ST[0]
                                                                    <GHC.Prim.RealWorld>_N
                                                                    <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                                       c>_R)) }
                                                  0##
                                                  -> Data.Trie.ArrayMapped.SparseArray.__impossible
                                                       @ (GHC.ST.ST
                                                            GHC.Prim.RealWorld
                                                            (Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                               c))
                                                       (GHC.CString.unpackCString#
                                                          "unionFilterWith_"#) } }
                                        0##
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.>=# ipv8 ipv1) of wild1 {
                                             GHC.Types.False
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.freezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ c
                                                        ipv3
                                                        0#
                                                        (GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv9))
                                                        s of ds1 { (#,#) ipv10 ipv11 ->
                                                 (# ipv10,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ c
                                                      ipv9
                                                      ipv11 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             c>_R))
                                             GHC.Types.True
                                             -> (\ (s :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                 case GHC.Prim.unsafeFreezeArray#
                                                        @ GHC.Prim.RealWorld
                                                        @ c
                                                        ipv3
                                                        s of ds1 { (#,#) ipv10 ipv11 ->
                                                 (# ipv10,
                                                    Data.Trie.ArrayMapped.SparseArray.SA
                                                      @ c
                                                      ipv9
                                                      ipv11 #) })
                                                  `cast`
                                                (Sym (GHC.ST.N:ST[0]
                                                          <GHC.Prim.RealWorld>_N
                                                          <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                             c>_R)) } } } } } } } }
                                  } in
                                  (go
                                     (GHC.Types.W# ipv)
                                     (GHC.Types.W#
                                        (GHC.Prim.and#
                                           ipv
                                           (GHC.Prim.int2Word#
                                              (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv)))))
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.I# 0#)
                                     (GHC.Types.W# 0##))
                                    `cast`
                                  (GHC.ST.N:ST[0]
                                       <GHC.Prim.RealWorld>_N
                                       <Data.Trie.ArrayMapped.SparseArray.SparseArray c>_R)
                                    ipv2 }) of ds1 { (#,#) ipv2 ipv3 ->
                          ipv3 }) -}
e7b4a95993ae8da31f06ebc1bbe7dcde
  $wunionL ::
    GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> GHC.Prim.Word#
    -> GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, Strictness: <S,U><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: GHC.Prim.Array# a)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Array# a) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           ipv :: GHC.Prim.Word# = GHC.Prim.or# ww ww2
                         } in
                         let {
                           ipv1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt# ipv)
                         } in
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                ipv1
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv2 ipv3 ->
                         letrec {
                           $wgo2 :: GHC.Prim.Word#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.Trie.ArrayMapped.SparseArray.SparseArray a #)
                             {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><S,U>, Inline: [0] -}
                           = \ (ww4 :: GHC.Prim.Word#)
                               (ww5 :: GHC.Prim.Int#)
                               (ww6 :: GHC.Prim.Int#)
                               (ww7 :: GHC.Prim.Int#)
                               (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww7 ipv1) of wild {
                               GHC.Types.False
                               -> case GHC.Prim.and# ww ww4 of wild1 {
                                    DEFAULT
                                    -> case GHC.Prim.indexArray# @ a ww1 ww5 of ds1 { Unit# ipv4 ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv3
                                              ww7
                                              ipv4
                                              w of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ipv
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww4 1#))))
                                       } in
                                       case GHC.Prim.and# ww2 ww4 of wild2 {
                                         DEFAULT
                                         -> $wgo2
                                              (GHC.Prim.and#
                                                 p
                                                 (GHC.Prim.int2Word#
                                                    (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                              (GHC.Prim.+# ww5 1#)
                                              (GHC.Prim.+# ww6 1#)
                                              (GHC.Prim.+# ww7 1#)
                                              s'
                                         0##
                                         -> $wgo2
                                              (GHC.Prim.and#
                                                 p
                                                 (GHC.Prim.int2Word#
                                                    (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                              (GHC.Prim.+# ww5 1#)
                                              ww6
                                              (GHC.Prim.+# ww7 1#)
                                              s' } } }
                                    0##
                                    -> case GHC.Prim.indexArray# @ a ww3 ww6 of ds1 { Unit# ipv4 ->
                                       case GHC.Prim.writeArray#
                                              @ GHC.Prim.RealWorld
                                              @ a
                                              ipv3
                                              ww7
                                              ipv4
                                              w of s' { DEFAULT ->
                                       let {
                                         p :: GHC.Prim.Word#
                                         = GHC.Prim.and#
                                             ipv
                                             (GHC.Prim.int2Word#
                                                (GHC.Prim.negateInt#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.uncheckedShiftL# ww4 1#))))
                                       } in
                                       $wgo2
                                         (GHC.Prim.and#
                                            p
                                            (GHC.Prim.int2Word#
                                               (GHC.Prim.negateInt# (GHC.Prim.word2Int# p))))
                                         ww5
                                         (GHC.Prim.+# ww6 1#)
                                         (GHC.Prim.+# ww7 1#)
                                         s' } } }
                               GHC.Types.True
                               -> case GHC.Prim.unsafeFreezeArray#
                                         @ GHC.Prim.RealWorld
                                         @ a
                                         ipv3
                                         w of ds1 { (#,#) ipv4 ipv5 ->
                                  (# ipv4, Data.Trie.ArrayMapped.SparseArray.SA @ a ipv ipv5 #) } }
                         } in
                         $wgo2
                           (GHC.Prim.and#
                              ipv
                              (GHC.Prim.int2Word#
                                 (GHC.Prim.negateInt# (GHC.Prim.word2Int# ipv))))
                           0#
                           0#
                           0#
                           ipv2 }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
72d14bb8cb3bd2f69180a58f015e4109
  type Bitmap = GHC.Types.Word
91d6579b53eb5d8e3c962c84e9acfa53
  type role DynamicSA nominal representational
  data DynamicSA s a
    = DSA {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Bitmap
          {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Key
          {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Index
          {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Index
          !(GHC.Prim.MutableArray# s a)
70ba13f0ee526bc28e358e640521f80c
  type Index = GHC.Types.Int
b3f93382ddd5f01b2a8ef7513a451946
  type Key = GHC.Word.Word8
7393728837bc8492f4ae395de7e6cd63
  type OneBit = Data.Trie.ArrayMapped.SparseArray.Bitmap
c48038d4f7bb9c300e9cddc90e0c39f8
  data SparseArray a
    = SA {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Bitmap
         !(GHC.Prim.Array# a)
908e4bb8ee25fc4f45b18a0ad6f77fa2
  data SubsingletonView a
    = IsEmpty
    | IsSingleton {-# UNPACK #-}Data.Trie.ArrayMapped.SparseArray.Key a
    | IsNotSubsingleton
a86fa26e840ce314ab7bec644a525638
  __impossible :: GHC.Base.String -> a
  {- Arity: 1, Strictness: <B,1*U>x, Inline: NOINLINE -}
c48038d4f7bb9c300e9cddc90e0c39f8
  __length ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U,A)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds1 ->
                 Data.Bits.$fBitsWord_$cpopCount (GHC.Types.W# dt) }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  __null ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds1 ->
                 case dt of ds2 {
                   DEFAULT -> GHC.Types.False 0## -> GHC.Types.True } }) -}
53604fe5b0a8bbaa9996848a84117c80
  __undefinedElem :: a
  {- Strictness: x, Inline: NOINLINE -}
6f936f6ed1a872177319ae40b4f191ba
  adjust ::
    (a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <L,1*C1(U)><S(S),1*U(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: a -> a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { GHC.Word.W8# ww1 ->
                 case w2 of ww2 { Data.Trie.ArrayMapped.SparseArray.SA ww3 ww4 ->
                 Data.Trie.ArrayMapped.SparseArray.$wadjust
                   @ a
                   w
                   ww1
                   ww3
                   ww4 } }) -}
066afb6e374637a3f1bb8011a300ab23
  adjust' ::
    (a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <L,1*C1(U)><S(S),1*U(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: a -> a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { GHC.Word.W8# ww1 ->
                 case w2 of ww2 { Data.Trie.ArrayMapped.SparseArray.SA ww3 ww4 ->
                 Data.Trie.ArrayMapped.SparseArray.$wadjust'
                   @ a
                   w
                   ww1
                   ww3
                   ww4 } }) -}
4cbbef01f0305e58147a6e80faf8bca6
  adjustK ::
    (a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> b
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b)
    -> b
  {- Arity: 5,
     Strictness: <L,1*C1(U)><S(S),1*U(U)><S(SS),1*U(U,U)><L,1*U><L,1*C1(U)>,
     Inline: INLINE (sat-args=5),
     Unfolding: InlineRule (5, False, False)
                (\ @ a
                   @ b
                   (f :: a -> a)
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (sa :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (unchanged :: b)
                   (changed :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                               -> b) ->
                 case k of k1 { GHC.Word.W8# ipv ->
                 case sa of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 let {
                   b1 :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ipv)
                 } in
                 let {
                   b2 :: Data.Trie.ArrayMapped.SparseArray.OneBit = GHC.Types.W# b1
                 } in
                 case GHC.Classes.neWord
                        (Data.Bits.$fBitsWord_$c.&. p b2)
                        (GHC.Types.W# 0##) of wild1 {
                   GHC.Types.False -> unchanged
                   GHC.Types.True
                   -> let {
                        maxN :: GHC.Types.Int
                        = Data.Bits.$fBitsWord_$cpopCount (GHC.Types.W# dt)
                      } in
                      changed
                        (GHC.Base.$
                           @ 'GHC.Types.PtrRepLifted
                           @ (forall s.
                              GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                           (GHC.ST.runST @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           (\ @ s ->
                            GHC.Base.$
                              @ 'GHC.Types.PtrRepLifted
                              @ (GHC.Prim.MutableArray# s a
                                 -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                              @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                              (Data.Trie.ArrayMapped.SparseArray.new_
                                 @ s
                                 @ a
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 maxN)
                              (\ (xs' :: GHC.Prim.MutableArray# s a) ->
                               GHC.ST.$fMonadST_$c>>
                                 @ s
                                 @ ()
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 (case maxN of wild2 { GHC.Types.I# n ->
                                  GHC.Base.$
                                    @ 'GHC.Types.PtrRepLifted
                                    @ (GHC.ST.STRep s ())
                                    @ (GHC.ST.ST s ())
                                    (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                                      `cast`
                                    (<GHC.ST.STRep s ()>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                                    (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                     case GHC.Prim.copyArray#
                                            @ a
                                            @ s
                                            xs
                                            0#
                                            xs'
                                            0#
                                            n
                                            s1 of s' { DEFAULT ->
                                     (# s', GHC.Tuple.() #) }) })
                                 (let {
                                    i :: Data.Trie.ArrayMapped.SparseArray.Index
                                    = Data.Bits.$fBitsWord_$cpopCount
                                        (Data.Bits.$fBitsWord_$c.&.
                                           p
                                           (GHC.Num.$fNumWord_$c- b2 (GHC.Types.W# 1##)))
                                  } in
                                  GHC.Base.$
                                    @ 'GHC.Types.PtrRepLifted
                                    @ (a
                                       -> GHC.ST.ST
                                            s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                    @ (GHC.ST.ST
                                         s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                    (Data.Trie.ArrayMapped.SparseArray.index
                                       @ a
                                       @ (GHC.ST.ST
                                            s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                       xs
                                       i)
                                    (\ (x :: a) ->
                                     GHC.ST.$fMonadST_$c>>
                                       @ s
                                       @ ()
                                       @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                       (case i of wild2 { GHC.Types.I# i1 ->
                                        GHC.Base.$
                                          @ 'GHC.Types.PtrRepLifted
                                          @ (GHC.ST.STRep s ())
                                          @ (GHC.ST.ST s ())
                                          (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                                            `cast`
                                          (<GHC.ST.STRep s ()>_R
                                           ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                                          (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                           case GHC.Prim.writeArray#
                                                  @ s
                                                  @ a
                                                  xs'
                                                  i1
                                                  (f x)
                                                  s1 of s' { DEFAULT ->
                                           (# s', GHC.Tuple.() #) }) })
                                       (GHC.Base.$
                                          @ 'GHC.Types.PtrRepLifted
                                          @ (GHC.ST.STRep
                                               s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                          @ (GHC.ST.ST
                                               s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                          (\ (tpl :: GHC.ST.STRep
                                                       s
                                                       (Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a)) ->
                                           tpl)
                                            `cast`
                                          (<GHC.ST.STRep
                                              s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)>_R
                                           ->_R Sym (GHC.ST.N:ST[0]
                                                         <s>_N
                                                         <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                            a>_R))
                                          (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeArray#
                                                  @ s
                                                  @ a
                                                  xs'
                                                  s1 of ds { (#,#) ipv1 ipv2 ->
                                           (# ipv1,
                                              Data.Trie.ArrayMapped.SparseArray.SA
                                                @ a
                                                dt
                                                ipv2 #) }))))))) } } }) -}
8b99ea630486768977e3e8253bf10446
  adjustK' ::
    (a -> a)
    -> Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> b
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b)
    -> b
  {- Arity: 5,
     Strictness: <L,1*C1(U)><S(S),1*U(U)><S(SS),1*U(U,U)><L,1*U><L,1*C1(U)>,
     Inline: INLINE (sat-args=5),
     Unfolding: InlineRule (5, False, False)
                (\ @ a
                   @ b
                   (f :: a -> a)
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (sa :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (unchanged :: b)
                   (changed :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
                               -> b) ->
                 case k of k1 { GHC.Word.W8# ipv ->
                 case sa of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 let {
                   b1 :: GHC.Prim.Word#
                   = GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ipv)
                 } in
                 let {
                   b2 :: Data.Trie.ArrayMapped.SparseArray.OneBit = GHC.Types.W# b1
                 } in
                 case GHC.Classes.neWord
                        (Data.Bits.$fBitsWord_$c.&. p b2)
                        (GHC.Types.W# 0##) of wild1 {
                   GHC.Types.False -> unchanged
                   GHC.Types.True
                   -> let {
                        maxN :: GHC.Types.Int
                        = Data.Bits.$fBitsWord_$cpopCount (GHC.Types.W# dt)
                      } in
                      changed
                        (GHC.Base.$
                           @ 'GHC.Types.PtrRepLifted
                           @ (forall s.
                              GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                           (GHC.ST.runST @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           (\ @ s ->
                            GHC.Base.$
                              @ 'GHC.Types.PtrRepLifted
                              @ (GHC.Prim.MutableArray# s a
                                 -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                              @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                              (Data.Trie.ArrayMapped.SparseArray.new_
                                 @ s
                                 @ a
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 maxN)
                              (\ (xs' :: GHC.Prim.MutableArray# s a) ->
                               GHC.ST.$fMonadST_$c>>
                                 @ s
                                 @ ()
                                 @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                 (case maxN of wild2 { GHC.Types.I# n ->
                                  GHC.Base.$
                                    @ 'GHC.Types.PtrRepLifted
                                    @ (GHC.ST.STRep s ())
                                    @ (GHC.ST.ST s ())
                                    (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                                      `cast`
                                    (<GHC.ST.STRep s ()>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                                    (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                     case GHC.Prim.copyArray#
                                            @ a
                                            @ s
                                            xs
                                            0#
                                            xs'
                                            0#
                                            n
                                            s1 of s' { DEFAULT ->
                                     (# s', GHC.Tuple.() #) }) })
                                 (let {
                                    i :: Data.Trie.ArrayMapped.SparseArray.Index
                                    = Data.Bits.$fBitsWord_$cpopCount
                                        (Data.Bits.$fBitsWord_$c.&.
                                           p
                                           (GHC.Num.$fNumWord_$c- b2 (GHC.Types.W# 1##)))
                                  } in
                                  GHC.Base.$
                                    @ 'GHC.Types.PtrRepLifted
                                    @ (a
                                       -> GHC.ST.ST
                                            s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                    @ (GHC.ST.ST
                                         s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                    (Data.Trie.ArrayMapped.SparseArray.index
                                       @ a
                                       @ (GHC.ST.ST
                                            s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                       xs
                                       i)
                                    (\ (x :: a) ->
                                     GHC.ST.$fMonadST_$c>>
                                       @ s
                                       @ ()
                                       @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                                       (GHC.Base.$!
                                          @ a
                                          @ (GHC.ST.ST s ())
                                          (Data.Trie.ArrayMapped.SparseArray.write @ s @ a xs' i)
                                          (f x))
                                       (GHC.Base.$
                                          @ 'GHC.Types.PtrRepLifted
                                          @ (GHC.ST.STRep
                                               s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                          @ (GHC.ST.ST
                                               s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                                          (\ (tpl :: GHC.ST.STRep
                                                       s
                                                       (Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                          a)) ->
                                           tpl)
                                            `cast`
                                          (<GHC.ST.STRep
                                              s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)>_R
                                           ->_R Sym (GHC.ST.N:ST[0]
                                                         <s>_N
                                                         <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                                            a>_R))
                                          (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeArray#
                                                  @ s
                                                  @ a
                                                  xs'
                                                  s1 of ds { (#,#) ipv1 ipv2 ->
                                           (# ipv1,
                                              Data.Trie.ArrayMapped.SparseArray.SA
                                                @ a
                                                dt
                                                ipv2 #) }))))))) } } }) -}
64442efc813f4c90063cbf1ccc0bc0f1
  assocs ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
  {- Arity: 1, HasNoCafRefs, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a ->
                 Data.Trie.ArrayMapped.SparseArray.assocsBy
                   @ a
                   @ (Data.Trie.ArrayMapped.SparseArray.Key, a)
                   (GHC.Tuple.(,) @ Data.Trie.ArrayMapped.SparseArray.Key @ a)) -}
9c2f57d9916b8f602390dff3c6b8f991
  assocsBy ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> [b]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 (cons :: b -> b1 -> b1)[OneShot] (nil :: b1)[OneShot] ->
                    Data.Trie.ArrayMapped.SparseArray.assocsByFB
                      @ a
                      @ b1
                      (\ (x :: Data.Trie.ArrayMapped.SparseArray.Key)
                         (x1 :: a)[OneShot] ->
                       cons (f x x1))
                      nil
                      xz)) -}
5c5fc6d5de5d6bdb7f010409d4a921fc
  assocsByFB ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> c -> c)
    -> c -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><L,U><S(SS),1*U(U,U)>,
     Inline: INLINE[0] (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ c
                   (cons_f :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> c -> c)
                   (nil :: c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 letrec {
                   go :: GHC.Prim.Array# a
                         -> Data.Trie.ArrayMapped.SparseArray.Index
                         -> GHC.Types.Word
                         -> Data.Trie.ArrayMapped.SparseArray.OneBit
                         -> Data.Trie.ArrayMapped.SparseArray.Key
                         -> c
                     {- Arity: 5 -}
                   = \ (xs :: GHC.Prim.Array# a)
                       (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                       (p :: GHC.Types.Word)
                       (b :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                       (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                     case i of i1 { GHC.Types.I# ipv ->
                     case p of p1 { GHC.Types.W# ipv1 ->
                     case b of b1 { GHC.Types.W# ipv2 ->
                     case k of k1 { GHC.Word.W8# ipv3 ->
                     case ipv1 of wild {
                       DEFAULT
                       -> case GHC.Prim.and# wild ipv2 of wild1 {
                            DEFAULT
                            -> cons_f
                                 k1
                                 (case GHC.Prim.indexArray# @ a xs ipv of ds { Unit# ipv4 -> ipv4 })
                                 (go
                                    xs
                                    (GHC.Types.I# (GHC.Prim.+# ipv 1#))
                                    (GHC.Types.W# (GHC.Prim.xor# wild ipv2))
                                    (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                    (GHC.Word.W8#
                                       (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##))))
                            0##
                            -> go
                                 xs
                                 i1
                                 p1
                                 (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv2 1#))
                                 (GHC.Word.W8#
                                    (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv3 1##))) }
                       0## -> nil } } } } }
                 } in
                 case eta of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 go
                   xs
                   (GHC.Types.I# 0#)
                   (GHC.Types.W# dt)
                   (GHC.Types.W# 1##)
                   (GHC.Word.W8# 0##) }) -}
d045d555df6a8b2123bc6080c16d3717
  c_ffs :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, False, False)
                (\ (ds :: GHC.Int.Int32) ->
                 case ds of ds1 { GHC.Int.I32# ds2 ->
                 case {__pkg_ccall bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX ffs GHC.Prim.Int#
                                                                                      -> GHC.Prim.State#
                                                                                           GHC.Prim.RealWorld
                                                                                      -> (# GHC.Prim.State#
                                                                                              GHC.Prim.RealWorld,
                                                                                            GHC.Prim.Int# #)}
                        ds2
                        GHC.Prim.realWorld# of wild { (#,#) ds3 ds4 ->
                 GHC.Int.I32# (GHC.Prim.narrow32Int# ds4) } })
                  `cast`
                (Sym (Foreign.C.Types.N:CInt[0])
                 ->_R Sym (Foreign.C.Types.N:CInt[0])) -}
d9b498f49623c06751a7e0efc2e0b759
  delete ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w of ww { GHC.Word.W8# ww1 ->
                 case w1 of ww2 { Data.Trie.ArrayMapped.SparseArray.SA ww3 ww4 ->
                 Data.Trie.ArrayMapped.SparseArray.$wdelete @ a ww1 ww3 ww4 } }) -}
06bca59a2599bba20dbbc141d688194e
  differenceL ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(SL),1*U(U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w1 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wdifferenceL
                   @ a
                   @ b
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
f74e6fcfecb66b5adf302259b0de0022
  differenceR ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <S(SL),1*U(U,A)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a @ b ->
                 GHC.Base.flip
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                   (Data.Trie.ArrayMapped.SparseArray.differenceL @ b @ a)) -}
9dccdabd4364d42313db01d9a5e8c5d0
  doubleton ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> a
    -> Data.Trie.ArrayMapped.SparseArray.Key
    -> a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><L,U><S(S),1*U(U)><L,U>,
     Inline: INLINE (sat-args=4),
     Unfolding: InlineRule (4, False, False)
                (\ @ a
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (x :: a)
                   (l :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (y :: a) ->
                 case k of k1 { GHC.Word.W8# ipv ->
                 case l of l1 { GHC.Word.W8# ipv1 ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (forall s.
                      GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (GHC.ST.runST @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                   (\ @ s ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (GHC.Prim.MutableArray# s a
                         -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                      @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                      (Data.Trie.ArrayMapped.SparseArray.new
                         @ a
                         @ s
                         @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                         (GHC.Types.I# 2#)
                         x)
                      (\ (xs :: GHC.Prim.MutableArray# s a) ->
                       GHC.ST.$fMonadST_$c>>
                         @ s
                         @ ()
                         @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                         (case GHC.Word.ltWord8 k1 l1 of wild {
                            GHC.Types.False
                            -> GHC.Base.$
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (GHC.ST.STRep s ())
                                 @ (GHC.ST.ST s ())
                                 (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                                   `cast`
                                 (<GHC.ST.STRep s ()>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                                 (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                  case GHC.Prim.writeArray# @ s @ a xs 0# y s1 of s' { DEFAULT ->
                                  (# s', GHC.Tuple.() #) })
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ 'GHC.Types.PtrRepLifted
                                 @ (GHC.ST.STRep s ())
                                 @ (GHC.ST.ST s ())
                                 (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                                   `cast`
                                 (<GHC.ST.STRep s ()>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                                 (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                                  case GHC.Prim.writeArray# @ s @ a xs 1# y s1 of s' { DEFAULT ->
                                  (# s', GHC.Tuple.() #) }) })
                         (case Data.Bits.$fBitsWord_$c.|.
                                 (GHC.Types.W#
                                    (GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ipv)))
                                 (GHC.Types.W#
                                    (GHC.Prim.uncheckedShiftL#
                                       1##
                                       (GHC.Prim.word2Int# ipv1))) of p { GHC.Types.W# ipv2 ->
                          GHC.Base.$
                            @ 'GHC.Types.PtrRepLifted
                            @ (GHC.ST.STRep
                                 s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                            @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                            (\ (tpl :: GHC.ST.STRep
                                         s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)) ->
                             tpl)
                              `cast`
                            (<GHC.ST.STRep
                                s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)>_R
                             ->_R Sym (GHC.ST.N:ST[0]
                                           <s>_N
                                           <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R))
                            (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                             case GHC.Prim.unsafeFreezeArray#
                                    @ s
                                    @ a
                                    xs
                                    s1 of ds { (#,#) ipv3 ipv4 ->
                             (# ipv3,
                                Data.Trie.ArrayMapped.SparseArray.SA
                                  @ a
                                  ipv2
                                  ipv4 #) }) }))) } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  elems :: Data.Trie.ArrayMapped.SparseArray.SparseArray a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (cons :: a -> b -> b)[OneShot] (nil :: b)[OneShot] ->
                    Data.Trie.ArrayMapped.SparseArray.elems_$cfoldr
                      @ a
                      @ b
                      cons
                      nil
                      xz)) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  elems_$cfoldr ::
    (a -> b -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$w$cfoldr
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2 }) -}
9072c30abab9be4e42631449e296e602
  empty :: Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Unfolding: (\ @ a ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (\ (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newArray#
                                @ a
                                @ GHC.Prim.RealWorld
                                0#
                                (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                                eta of ds { (#,#) ipv ipv1 ->
                         case GHC.Prim.unsafeFreezeArray#
                                @ GHC.Prim.RealWorld
                                @ a
                                ipv1
                                ipv of ds1 { (#,#) ipv2 ipv3 ->
                         (# ipv2,
                            Data.Trie.ArrayMapped.SparseArray.SA
                              @ a
                              0##
                              ipv3 #) } }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
5f56accf450006874976d8037d2eda96
  filter ::
    (a -> GHC.Types.Bool)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfilter @ a w ww1 ww2 }) -}
236cfc07e7d353c364d82b97324be35e
  filterMap ::
    (a -> GHC.Base.Maybe b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: a -> GHC.Base.Maybe b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfilterMap
                   @ a
                   @ b
                   w
                   ww1
                   ww2 }) -}
2878f75e8e67481016bf4fb7f5a90413
  filterMapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Base.Maybe b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key
                         -> a -> GHC.Base.Maybe b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfilterMapWithKey
                   @ a
                   @ b
                   w
                   ww1
                   ww2 }) -}
7dd8fa386e8e5c50371058fbb675cd71
  filterWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfilterWithKey
                   @ a
                   w
                   ww1
                   ww2 }) -}
a47224714cd661c86ebd37b9fbbafb32
  foldL ::
    (b -> a -> Data.Either.Either b c)
    -> b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Either.Either b c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   @ c
                   (w :: b -> a -> Data.Either.Either b c)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldL
                   @ b
                   @ a
                   @ c
                   w
                   w1
                   ww1
                   ww2 }) -}
81884423124ccab8baf52ac6181a6e15
  foldR ::
    (a -> b -> Data.Either.Either b c)
    -> b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Either.Either b c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> Data.Either.Either b c)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldR
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2 }) -}
3eb8d59633982e18845c2adc5ee6c773
  foldlWithKey ::
    (b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,1*U><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldlWithKey
                   @ b
                   @ a
                   w
                   w1
                   ww1
                   ww2 }) -}
19ecdbee0396df35a769054b0de44277
  foldlWithKey' ::
    (b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,1*U><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldlWithKey'
                   @ b
                   @ a
                   w
                   w1
                   ww1
                   ww2 }) -}
07618c0795af111847f7e1a792d9bead
  foldrWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><L,U><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldrWithKey
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2 }) -}
9d907866fbece0cf343832e8f98ca341
  foldrWithKey' ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
    -> b -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(U)))><S,U><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> b)
                   (w1 :: b)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfoldrWithKey'
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2 }) -}
ae73ab51d13df083ac3ef8a6bf9dc6a9
  fromList ::
    [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 1, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a ->
                 Data.Trie.ArrayMapped.SparseArray.fromList_
                   @ a
                   (GHC.Types.I# 16#)) -}
97ec4320c17a4ebfe6fe773a1769b103
  fromList_ ::
    GHC.Types.Int
    -> [(Data.Trie.ArrayMapped.SparseArray.Key, a)]
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Types.Int)
                   (w1 :: [(Data.Trie.ArrayMapped.SparseArray.Key, a)]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Trie.ArrayMapped.SparseArray.$wfromList_ @ a ww1 w1 }) -}
7cf2be3bb3b49fa787692b28f1465dd9
  getFirstBit ::
    Data.Trie.ArrayMapped.SparseArray.Bitmap
    -> Data.Trie.ArrayMapped.SparseArray.OneBit
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (p :: Data.Trie.ArrayMapped.SparseArray.Bitmap) ->
                 Data.Bits.$fBitsWord_$c.&. p (GHC.Num.$fNumWord_$cnegate p)) -}
351bf19ba77d78b9cf13bd18773df135
  index ::
    GHC.Prim.Array# a
    -> Data.Trie.ArrayMapped.SparseArray.Index -> (a -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U><S(S),1*U(U)><C(S),1*C1(U)>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ r
                   (xs :: GHC.Prim.Array# a)
                   (ds :: GHC.Types.Int)
                   (continue :: a -> r) ->
                 case ds of wild { GHC.Types.I# i ->
                 case GHC.Prim.indexArray# @ a xs i of ds1 { Unit# ipv ->
                 continue ipv } }) -}
a4b0ae033b402de700bd0790e3a0573d
  insert ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,U><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (w1 :: a)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w of ww { GHC.Word.W8# ww1 ->
                 case w2 of ww2 { Data.Trie.ArrayMapped.SparseArray.SA ww3 ww4 ->
                 Data.Trie.ArrayMapped.SparseArray.$winsert
                   @ a
                   ww1
                   w1
                   ww3
                   ww4 } }) -}
eec8bcf08664b595b630faebc2385f74
  insert' ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (x :: a)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case k of k1 { GHC.Word.W8# ipv ->
                 case x of x1 { DEFAULT ->
                 Data.Trie.ArrayMapped.SparseArray.insert @ a k1 x1 eta } }) -}
b3813445f1e43443776eea304c1712c0
  intersectionL ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(SL),1*U(U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w1 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wintersectionL
                   @ a
                   @ b
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
5de43dc84b368ef08a0a51607715493e
  intersectionR ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <S(SL),1*U(U,A)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a @ b ->
                 GHC.Base.flip
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
                   (Data.Trie.ArrayMapped.SparseArray.intersectionL @ b @ a)) -}
4ebca6f9010b57f514cab44d233928d4
  intersectionWith ::
    (a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3,
     Strictness: <L,C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w2 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wintersectionWith
                   @ a
                   @ b
                   @ c
                   w
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
a956b4e61db28d803ff4041fca9ee562
  intersectionWith' ::
    (a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3,
     Strictness: <L,C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w2 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wintersectionWith'
                   @ a
                   @ b
                   @ c
                   w
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
16fdfa7554b2f2beccec0fa6d5813de5
  isSubarrayOf ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U,A)><S(SL),1*U(U,A)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (ds1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds2 ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 case ds1 of wild1 { Data.Trie.ArrayMapped.SparseArray.SA dt1 ds3 ->
                 GHC.Classes.eqWord
                   (Data.Bits.$fBitsWord_$c.&. p (GHC.Types.W# dt1))
                   p } }) -}
a5370ada2f088f2497bbb654508cc76d
  key2bit ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.OneBit
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                 case k of wild { GHC.Word.W8# x# ->
                 GHC.Types.W#
                   (GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# x#)) }) -}
407f01d2ee21a81fdc352f6e22f8164f
  keys ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> [Data.Trie.ArrayMapped.SparseArray.Key]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U,A)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 GHC.Base.build
                   @ Data.Trie.ArrayMapped.SparseArray.Key
                   (\ @ b
                      (cons :: Data.Trie.ArrayMapped.SparseArray.Key -> b -> b)[OneShot]
                      (nil :: b)[OneShot] ->
                    Data.Trie.ArrayMapped.SparseArray.keysFB @ b @ a cons nil xz)) -}
71b96b13b56ec66bc42c23c230ee5ce8
  keysFB ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> c -> c)
    -> c -> Data.Trie.ArrayMapped.SparseArray.SparseArray a -> c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SL),1*U(U,A)>,
     Inline: INLINE[0] (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ c
                   @ a
                   (cons :: Data.Trie.ArrayMapped.SparseArray.Key -> c -> c)
                   (nil :: c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 letrec {
                   go :: GHC.Types.Word
                         -> Data.Trie.ArrayMapped.SparseArray.OneBit
                         -> Data.Trie.ArrayMapped.SparseArray.Key
                         -> c
                     {- Arity: 3 -}
                   = \ (p :: GHC.Types.Word)
                       (b :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                       (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                     case p of p1 { GHC.Types.W# ipv ->
                     case b of b1 { GHC.Types.W# ipv1 ->
                     case k of k1 { GHC.Word.W8# ipv2 ->
                     case ipv of wild {
                       DEFAULT
                       -> case GHC.Prim.and# wild ipv1 of wild1 {
                            DEFAULT
                            -> cons
                                 k1
                                 (go
                                    (GHC.Types.W# (GHC.Prim.xor# wild ipv1))
                                    (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv1 1#))
                                    (GHC.Word.W8#
                                       (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv2 1##))))
                            0##
                            -> go
                                 p1
                                 (GHC.Types.W# (GHC.Prim.uncheckedShiftL# ipv1 1#))
                                 (GHC.Word.W8#
                                    (GHC.Prim.narrow8Word# (GHC.Prim.plusWord# ipv2 1##))) }
                       0## -> nil } } } }
                 } in
                 case eta of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds ->
                 go (GHC.Types.W# dt) (GHC.Types.W# 1##) (GHC.Word.W8# 1##) }) -}
00e806ee9f28a38a59580c0e6aacbd6b
  length ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U,A)>m,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Trie.ArrayMapped.SparseArray.__length -}
21bdfc8c75d69ec78962eb3c53dcfe73
  lookup ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 let {
                   b :: Data.Trie.ArrayMapped.SparseArray.OneBit
                   = case k of wild1 { GHC.Word.W8# x# ->
                     GHC.Types.W#
                       (GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# x#)) }
                 } in
                 case GHC.Classes.neWord
                        (Data.Bits.$fBitsWord_$c.&. p b)
                        (GHC.Types.W# 0##) of wild1 {
                   GHC.Types.False -> GHC.Base.Nothing @ a
                   GHC.Types.True
                   -> case Data.Bits.$fBitsWord_$cpopCount
                             (Data.Bits.$fBitsWord_$c.&.
                                p
                                (GHC.Num.$fNumWord_$c-
                                   b
                                   (GHC.Types.W# 1##))) of wild2 { GHC.Types.I# i ->
                      case GHC.Prim.indexArray# @ a xs i of ds1 { Unit# ipv ->
                      GHC.Base.Just @ a ipv } } } }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  map ::
    (a -> b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wmap @ a @ b w ww1 ww2 }) -}
c48038d4f7bb9c300e9cddc90e0c39f8
  map' ::
    (a -> b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wmap' @ a @ b w ww1 ww2 }) -}
cf931e4463cbd7992bd70ce4d1923592
  mapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wmapWithKey
                   @ a
                   @ b
                   w
                   ww1
                   ww2 }) -}
7b2dac706fe20408493d2ba20018173a
  mapWithKey' ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wmapWithKey'
                   @ a
                   @ b
                   w
                   ww1
                   ww2 }) -}
4a54633ab984e156cf5b0af23317a01c
  member ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SL),1*U(U,A)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds1 ->
                 GHC.Classes.neWord
                   (Data.Bits.$fBitsWord_$c.&.
                      (GHC.Types.W# dt)
                      (Data.Trie.ArrayMapped.SparseArray.key2bit k))
                   (GHC.Types.W# 0##) }) -}
dbbdab7668ecb3059e535d5740753cf4
  new ::
    GHC.Types.Int
    -> a
    -> (GHC.Prim.MutableArray# s a -> GHC.ST.ST s r)
    -> GHC.ST.ST s r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><L,U><C(C(S)),1*C1(C1(U(U,U)))><S,U>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ s
                   @ r
                   (_n :: GHC.Types.Int)
                   (x :: a)
                   (continue :: GHC.Prim.MutableArray# s a -> GHC.ST.ST s r) ->
                 case _n of wild { GHC.Types.I# n ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.ST.STRep s r)
                   @ (GHC.ST.ST s r)
                   (\ (tpl :: GHC.ST.STRep s r) -> tpl)
                     `cast`
                   (<GHC.ST.STRep s r>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <r>_R))
                   (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                    case GHC.Prim.newArray# @ a @ s n x s1 of ds { (#,#) ipv ipv1 ->
                    (continue ipv1) `cast` (GHC.ST.N:ST[0] <s>_N <r>_R) ipv }) }) -}
fd2fd745659876f7515b7d451867f5bd
  new_ ::
    GHC.Types.Int
    -> (GHC.Prim.MutableArray# s a -> GHC.ST.ST s r) -> GHC.ST.ST s r
  {- Arity: 3, Strictness: <L,U(U)>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s
                   @ a
                   @ r
                   (n :: GHC.Types.Int)
                   (eta :: GHC.Prim.MutableArray# s a -> GHC.ST.ST s r)
                   (eta1 :: GHC.Prim.State# s)[OneShot] ->
                 case n of wild { GHC.Types.I# n1 ->
                 (GHC.Base.$
                    @ 'GHC.Types.PtrRepLifted
                    @ (GHC.ST.STRep s r)
                    @ (GHC.ST.ST s r)
                    (\ (tpl :: GHC.ST.STRep s r) -> tpl)
                      `cast`
                    (<GHC.ST.STRep s r>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <r>_R))
                    (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                     case GHC.Prim.newArray#
                            @ a
                            @ s
                            n1
                            (Data.Trie.ArrayMapped.SparseArray.__undefinedElem @ a)
                            s1 of ds { (#,#) ipv ipv1 ->
                     (eta ipv1) `cast` (GHC.ST.N:ST[0] <s>_N <r>_R) ipv }))
                   `cast`
                 (GHC.ST.N:ST[0] <s>_N <r>_R)
                   eta1 })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (r :: <*>_N).
                 <GHC.Types.Int>_R
                 ->_R <GHC.Prim.MutableArray# s a -> GHC.ST.ST s r>_R
                 ->_R Sym (GHC.ST.N:ST[0] <s>_N <r>_R)) -}
1afed76ffd4331e8d7048e8be751c46c
  notMember ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SL),1*U(U,A)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                   (ds :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case ds of wild { Data.Trie.ArrayMapped.SparseArray.SA dt ds1 ->
                 GHC.Classes.eqWord
                   (Data.Bits.$fBitsWord_$c.&.
                      (GHC.Types.W# dt)
                      (Data.Trie.ArrayMapped.SparseArray.key2bit k))
                   (GHC.Types.W# 0##) }) -}
7cb3102404d514a82513eec7e4e52b74
  null ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Trie.ArrayMapped.SparseArray.__null -}
dc541fde029bf54ffe49aaf5985aec87
  partition ::
    (a -> GHC.Types.Bool)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
        Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wpartition @ a w ww1 ww2 }) -}
9c3aef83c816095900db53f442ea512f
  partitionMap ::
    (a -> Data.Either.Either b c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
        Data.Trie.ArrayMapped.SparseArray.SparseArray c)
  {- Arity: 2, Strictness: <L,C(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> Data.Either.Either b c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wpartitionMap
                   @ a
                   @ b
                   @ c
                   w
                   ww1
                   ww2 }) -}
7d4b4ddea03fe8f2ddd830ddb5eb6d0a
  partitionMapWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key
     -> a -> Data.Either.Either b c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray b,
        Data.Trie.ArrayMapped.SparseArray.SparseArray c)
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key
                         -> a -> Data.Either.Either b c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wpartitionMapWithKey
                   @ a
                   @ b
                   @ c
                   w
                   ww1
                   ww2 }) -}
5b25bec39d686004ba10bb2d19b7dfa2
  partitionWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> (Data.Trie.ArrayMapped.SparseArray.SparseArray a,
        Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> GHC.Types.Bool)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wpartitionWithKey
                   @ a
                   w
                   ww1
                   ww2 }) -}
d5c8f97de30a4d44bf45d112c25b5954
  rzip ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray
         (GHC.Base.Maybe a, b)
  {- Arity: 2,
     Unfolding: (\ @ a
                   @ b
                   (w :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w1 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipWith_
                   @ a
                   @ b
                   @ (GHC.Base.Maybe a, b)
                   (Data.Trie.ArrayMapped.SparseArray.rzip2 @ a @ b)
                   (Data.Trie.ArrayMapped.SparseArray.rzip1 @ a @ b)
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
b3c79e48a92731cafdc9b8d5a62e8c4c
  rzip1 :: b -> (GHC.Base.Maybe a, b)
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a @ b ->
                 GHC.Tuple.(,) @ (GHC.Base.Maybe a) @ b (GHC.Base.Nothing @ a)) -}
a1b5d50600b7c159d1ef6f8d0918346d
  rzip2 :: a -> b -> (GHC.Base.Maybe a, b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: a) (eta :: b) -> (GHC.Base.Just @ a x, eta)) -}
2e5d2ef5fca005d51bcbc23633c28fc0
  rzipFilter ::
    (GHC.Base.Maybe a -> b -> GHC.Base.Maybe c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 1, Strictness: <L,C(C(U))>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ b @ c (f :: GHC.Base.Maybe a -> b -> GHC.Base.Maybe c) ->
                 Data.Trie.ArrayMapped.SparseArray.rzipFilter_
                   @ a
                   @ b
                   @ c
                   (\ (x :: a) -> f (GHC.Base.Just @ a x))
                   (f (GHC.Base.Nothing @ a))) -}
facf7d6382f925e1c2a4bca2a4ade9f4
  rzipFilter_ ::
    (a -> b -> GHC.Base.Maybe c)
    -> (b -> GHC.Base.Maybe c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 4,
     Strictness: <L,C(C1(U))><L,C(U)><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> GHC.Base.Maybe c)
                   (w1 :: b -> GHC.Base.Maybe c)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w3 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipFilter_
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
f45816d43e5e71ab92cd78636f43a4cb
  rzipWith ::
    (GHC.Base.Maybe a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 1, Strictness: <L,C(C(U))>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ b @ c (f :: GHC.Base.Maybe a -> b -> c) ->
                 Data.Trie.ArrayMapped.SparseArray.rzipWith_
                   @ a
                   @ b
                   @ c
                   (\ (x :: a) -> f (GHC.Base.Just @ a x))
                   (f (GHC.Base.Nothing @ a))) -}
7d978cc52ba78f51bc28d4b486358d35
  rzipWith' ::
    (GHC.Base.Maybe a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 1, Strictness: <L,C(C(U))>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ b @ c (f :: GHC.Base.Maybe a -> b -> c) ->
                 Data.Trie.ArrayMapped.SparseArray.rzipWith'_
                   @ a
                   @ b
                   @ c
                   (\ (x :: a) -> f (GHC.Base.Just @ a x))
                   (f (GHC.Base.Nothing @ a))) -}
c682084a4b215e46e74b940f358b6f1f
  rzipWith'_ ::
    (a -> b -> c)
    -> (b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 4,
     Strictness: <L,C(C1(U))><L,C(U)><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: b -> c)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w3 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipWith'_
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
ebac1b6a72005ab35604b86cb78f925c
  rzipWithKey ::
    (Data.Trie.ArrayMapped.SparseArray.Key
     -> GHC.Base.Maybe a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3, Strictness: <L,C(U)><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.Trie.ArrayMapped.SparseArray.Key
                         -> GHC.Base.Maybe a -> b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.rzipWithKey_
                   @ a
                   @ b
                   @ c
                   (\ (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                      (x :: a)[OneShot] ->
                    f k (GHC.Base.Just @ a x))
                   (\ (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                    f k (GHC.Base.Nothing @ a))
                   eta
                   eta1) -}
7b65de526f10f06a464dbfd83755e7d3
  rzipWithKey' ::
    (Data.Trie.ArrayMapped.SparseArray.Key
     -> GHC.Base.Maybe a -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3, Strictness: <L,C(U)><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.Trie.ArrayMapped.SparseArray.Key
                         -> GHC.Base.Maybe a -> b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.rzipWithKey'_
                   @ a
                   @ b
                   @ c
                   (\ (k :: Data.Trie.ArrayMapped.SparseArray.Key)
                      (x :: a)[OneShot] ->
                    f k (GHC.Base.Just @ a x))
                   (\ (k :: Data.Trie.ArrayMapped.SparseArray.Key) ->
                    f k (GHC.Base.Nothing @ a))
                   eta
                   eta1) -}
cab6f6043a8811166f6fd45c6b3a5f02
  rzipWithKey'_ ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
    -> (Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 4,
     Strictness: <L,C(C1(C1(U)))><L,C(C1(U))><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w3 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipWithKey'_
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
3b36bf96144ccb4e904ee71b7c47bb59
  rzipWithKey_ ::
    (Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
    -> (Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 4,
     Strictness: <L,C(C1(C1(U)))><L,C(C1(U))><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: Data.Trie.ArrayMapped.SparseArray.Key -> a -> b -> c)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.Key -> b -> c)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w3 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipWithKey_
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
1c92696b393a118fa6bdabec5f611b3b
  rzipWith_ ::
    (a -> b -> c)
    -> (b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 4,
     Strictness: <L,C(C1(U))><L,C(U)><S(LS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: b -> c)
                   (w2 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w2 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w3 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wrzipWith_
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
2f5907688ea7cade76c103532c026313
  sequenceST ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray (GHC.ST.ST s a)
    -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.ArrayMapped.SparseArray.sequenceST1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Data.Trie.ArrayMapped.SparseArray.SparseArray (GHC.ST.ST s a)>_R
                 ->_R Sym (GHC.ST.N:ST[0]
                               <s>_N <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R)) -}
23d1b068d116a43eb955aed84135699b
  sequenceST1 ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray (GHC.ST.ST s a)
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Trie.ArrayMapped.SparseArray.SparseArray a #)
  {- Arity: 2,
     Unfolding: (\ @ s
                   @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.SparseArray
                           (GHC.ST.ST s a))
                   (w1 :: GHC.Prim.State# s)[OneShot] ->
                 case w of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wtraverseST
                   @ (GHC.ST.ST s a)
                   @ s
                   @ a
                   (GHC.Base.id @ (GHC.ST.ST s a))
                   ww1
                   ww2
                   w1 }) -}
00ef93cda671862d0fa3d07b6c5c9947
  singleton ::
    Data.Trie.ArrayMapped.SparseArray.Key
    -> a -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a (k :: Data.Trie.ArrayMapped.SparseArray.Key) (x :: a) ->
                 case k of k1 { GHC.Word.W8# ipv ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                        (GHC.Base.$
                           @ 'GHC.Types.PtrRepLifted
                           @ (GHC.Prim.MutableArray# GHC.Prim.RealWorld a
                              -> GHC.ST.ST
                                   GHC.Prim.RealWorld
                                   (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           @ (GHC.ST.ST
                                GHC.Prim.RealWorld
                                (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                           (Data.Trie.ArrayMapped.SparseArray.new
                              @ a
                              @ GHC.Prim.RealWorld
                              @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                              (GHC.Types.I# 1#)
                              x)
                           (Data.Trie.ArrayMapped.SparseArray.unsafeFreeze
                              @ GHC.Prim.RealWorld
                              @ a
                              (GHC.Types.W#
                                 (GHC.Prim.uncheckedShiftL# 1## (GHC.Prim.word2Int# ipv)))))
                          `cast`
                        (GHC.ST.N:ST[0]
                             <GHC.Prim.RealWorld>_N
                             <Data.Trie.ArrayMapped.SparseArray.SparseArray
                                a>_R) of ds1 { (#,#) ipv1 ipv2 ->
                 ipv2 } }) -}
9137c7be2e6802fccd22b90e6923f591
  traverseST ::
    (a -> GHC.ST.ST s b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
  {- Arity: 3, Strictness: <L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Trie.ArrayMapped.SparseArray.traverseST1
                  `cast`
                (forall (a :: <*>_N) (s :: <*>_N) (b :: <*>_N).
                 <a -> GHC.ST.ST s b>_R
                 ->_R <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
                 ->_R Sym (GHC.ST.N:ST[0]
                               <s>_N <Data.Trie.ArrayMapped.SparseArray.SparseArray b>_R)) -}
60c79eb0e2e4bc2448699cd2db03deec
  traverseST1 ::
    (a -> GHC.ST.ST s b)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Trie.ArrayMapped.SparseArray.SparseArray b #)
  {- Arity: 3, Strictness: <L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ s
                   @ b
                   (w :: a -> GHC.ST.ST s b)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w2 :: GHC.Prim.State# s)[OneShot] ->
                 case w1 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 Data.Trie.ArrayMapped.SparseArray.$wtraverseST
                   @ a
                   @ s
                   @ b
                   w
                   ww1
                   ww2
                   w2 }) -}
18fad3faddf2f919c27a48501c44d554
  unionFilterWith ::
    (Data.Or.Or a b -> GHC.Base.Maybe c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3, Strictness: <L,C(U)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.Or.Or a b -> GHC.Base.Maybe c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.unionFilterWith_
                   @ a
                   @ c
                   @ b
                   (\ (x :: a) -> f (Data.Or.Fst @ a @ b x))
                   (\ (x :: a) (x1 :: b)[OneShot] -> f (Data.Or.Both @ a @ b x x1))
                   (\ (x :: b) -> f (Data.Or.Snd @ a @ b x))
                   eta
                   eta1) -}
e5162f06f5ef29306d4d0dd60076ee72
  unionFilterWith_ ::
    (a -> GHC.Base.Maybe c)
    -> (a -> b -> GHC.Base.Maybe c)
    -> (b -> GHC.Base.Maybe c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 5,
     Strictness: <L,C(U)><L,C(C1(U))><L,C(U)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ c
                   @ b
                   (w :: a -> GHC.Base.Maybe c)
                   (w1 :: a -> b -> GHC.Base.Maybe c)
                   (w2 :: b -> GHC.Base.Maybe c)
                   (w3 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w4 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case w3 of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w4 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wunionFilterWith_
                   @ a
                   @ c
                   @ b
                   w
                   w1
                   w2
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
4124037aad7fb961db12c51647893849
  unionL ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (w1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case w of ww { Data.Trie.ArrayMapped.SparseArray.SA ww1 ww2 ->
                 case w1 of ww3 { Data.Trie.ArrayMapped.SparseArray.SA ww4 ww5 ->
                 Data.Trie.ArrayMapped.SparseArray.$wunionL
                   @ a
                   ww1
                   ww2
                   ww4
                   ww5 } }) -}
ab6fd3d7c7c7eb52f199d1137b810f06
  unionR ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a ->
                 GHC.Base.flip
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (Data.Trie.ArrayMapped.SparseArray.unionL @ a)) -}
eeeaac2bba97872f2c4b36e294b0760c
  unionWith ::
    (Data.Or.Or a b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3, Strictness: <L,C(U)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.Or.Or a b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.unionWith_
                   @ a
                   @ c
                   @ b
                   (\ (x :: a) -> f (Data.Or.Fst @ a @ b x))
                   (\ (x :: a) (x1 :: b)[OneShot] -> f (Data.Or.Both @ a @ b x x1))
                   (\ (x :: b) -> f (Data.Or.Snd @ a @ b x))
                   eta
                   eta1) -}
631214738ec5eb2ee6d837017644b77c
  unionWith' ::
    (Data.Or.Or a b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 3, Strictness: <L,C(U)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ c
                   (f :: Data.Or.Or a b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 Data.Trie.ArrayMapped.SparseArray.unionWith'_
                   @ a
                   @ c
                   @ b
                   (\ (x :: a) -> f (Data.Or.Fst @ a @ b x))
                   (\ (x :: a) (x1 :: b)[OneShot] -> f (Data.Or.Both @ a @ b x x1))
                   (\ (x :: b) -> f (Data.Or.Snd @ a @ b x))
                   eta
                   eta1) -}
43019329ddb180009d290861665058cb
  unionWith'_ ::
    (a -> c)
    -> (a -> b -> c)
    -> (b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 5, Strictness: <L,C(U)><L,C(C1(U))><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ c
                   @ b
                   (f :: a -> c)
                   (g :: a -> b -> c)
                   (h :: b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case eta of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 case eta1 of wild1 { Data.Trie.ArrayMapped.SparseArray.SA dt1 ys ->
                 let {
                   q :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt1
                 } in
                 let {
                   ds :: (Data.Trie.ArrayMapped.SparseArray.Bitmap)
                   = case Data.Bits.$fBitsWord_$c.|. p q of r { GHC.Types.W# ipv ->
                     (r) }
                 } in
                 let {
                   r :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                   = case ds of ds1 { Unit r1 -> r1 }
                 } in
                 case ds of ds1 { Unit ipv ->
                 let {
                   ds2 :: (GHC.Types.Int)
                   = case Data.Bits.$fBitsWord_$cpopCount
                            r of n { GHC.Types.I# ipv1 ->
                     (n) }
                 } in
                 let {
                   n :: GHC.Types.Int = case ds2 of ds3 { Unit n1 -> n1 }
                 } in
                 case ds2 of ds3 { Unit ipv1 ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (forall s.
                      GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                   (GHC.ST.runST @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                   (\ @ s ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (GHC.Prim.MutableArray# s c
                         -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                      @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                      (Data.Trie.ArrayMapped.SparseArray.new_
                         @ s
                         @ c
                         @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                         n)
                      (\ (zs :: GHC.Prim.MutableArray# s c) ->
                       letrec {
                         go :: Data.Trie.ArrayMapped.SparseArray.OneBit
                               -> Data.Trie.ArrayMapped.SparseArray.Index
                               -> GHC.Types.Int
                               -> GHC.Types.Int
                               -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                           {- Arity: 4 -}
                         = \ (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                             (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                             (j :: GHC.Types.Int)
                             (k :: GHC.Types.Int) ->
                           case b1 of b2 { GHC.Types.W# ipv2 ->
                           case i of i1 { GHC.Types.I# ipv3 ->
                           case j of j1 { GHC.Types.I# ipv4 ->
                           case k of k1 { GHC.Types.I# ipv5 ->
                           case GHC.Classes.geInt k1 n of wild2 {
                             GHC.Types.False
                             -> let {
                                  ds4 :: GHC.Types.Bool
                                  = GHC.Classes.neWord
                                      (Data.Bits.$fBitsWord_$c.&. q b2)
                                      (GHC.Types.W# 0##)
                                } in
                                case GHC.Classes.neWord
                                       (Data.Bits.$fBitsWord_$c.&. p b2)
                                       (GHC.Types.W# 0##) of wild3 {
                                  GHC.Types.False
                                  -> case ds4 of wild4 {
                                       GHC.Types.False
                                       -> Data.Trie.ArrayMapped.SparseArray.__impossible
                                            @ (GHC.ST.ST
                                                 s
                                                 (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                                            (GHC.Base.build
                                               @ GHC.Types.Char
                                               (\ @ b3 ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b3
                                                  "__unionWith"#))
                                       GHC.Types.True
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$!
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (h (case GHC.Prim.indexArray#
                                                          @ b
                                                          ys
                                                          ipv4 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               i1
                                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#))) }
                                  GHC.Types.True
                                  -> case ds4 of wild4 {
                                       GHC.Types.False
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$!
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (f (case GHC.Prim.indexArray#
                                                          @ a
                                                          xs
                                                          ipv3 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# 1#))
                                               j1
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#)))
                                       GHC.Types.True
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$!
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (g (case GHC.Prim.indexArray#
                                                          @ a
                                                          xs
                                                          ipv3 of ds5 { Unit# ipv6 ->
                                                   ipv6 })
                                                  (case GHC.Prim.indexArray#
                                                          @ b
                                                          ys
                                                          ipv4 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#))) } }
                             GHC.Types.True
                             -> Data.Trie.ArrayMapped.SparseArray.unsafeFreeze
                                  @ s
                                  @ c
                                  r
                                  zs } } } } }
                       } in
                       go
                         (Data.Trie.ArrayMapped.SparseArray.getFirstBit r)
                         (GHC.Types.I# 0#)
                         (GHC.Types.I# 0#)
                         (GHC.Types.I# 0#))) } } } }) -}
6c1816caf9f106616b15a5b6f8f2accc
  unionWith_ ::
    (a -> c)
    -> (a -> b -> c)
    -> (b -> c)
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray b
    -> Data.Trie.ArrayMapped.SparseArray.SparseArray c
  {- Arity: 5, Strictness: <L,C(U)><L,C(C1(U))><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ c
                   @ b
                   (f :: a -> c)
                   (g :: a -> b -> c)
                   (h :: b -> c)
                   (eta :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
                   (eta1 :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
                 case eta of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 let {
                   p :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt
                 } in
                 case eta1 of wild1 { Data.Trie.ArrayMapped.SparseArray.SA dt1 ys ->
                 let {
                   q :: Data.Trie.ArrayMapped.SparseArray.Bitmap = GHC.Types.W# dt1
                 } in
                 let {
                   ds :: (Data.Trie.ArrayMapped.SparseArray.Bitmap)
                   = case Data.Bits.$fBitsWord_$c.|. p q of r { GHC.Types.W# ipv ->
                     (r) }
                 } in
                 let {
                   r :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                   = case ds of ds1 { Unit r1 -> r1 }
                 } in
                 case ds of ds1 { Unit ipv ->
                 let {
                   ds2 :: (GHC.Types.Int)
                   = case Data.Bits.$fBitsWord_$cpopCount
                            r of n { GHC.Types.I# ipv1 ->
                     (n) }
                 } in
                 let {
                   n :: GHC.Types.Int = case ds2 of ds3 { Unit n1 -> n1 }
                 } in
                 case ds2 of ds3 { Unit ipv1 ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (forall s.
                      GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                   @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                   (GHC.ST.runST @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                   (\ @ s ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (GHC.Prim.MutableArray# s c
                         -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                      @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                      (Data.Trie.ArrayMapped.SparseArray.new_
                         @ s
                         @ c
                         @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                         n)
                      (\ (zs :: GHC.Prim.MutableArray# s c) ->
                       letrec {
                         go :: Data.Trie.ArrayMapped.SparseArray.OneBit
                               -> Data.Trie.ArrayMapped.SparseArray.Index
                               -> GHC.Types.Int
                               -> GHC.Types.Int
                               -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                           {- Arity: 4 -}
                         = \ (b1 :: Data.Trie.ArrayMapped.SparseArray.OneBit)
                             (i :: Data.Trie.ArrayMapped.SparseArray.Index)
                             (j :: GHC.Types.Int)
                             (k :: GHC.Types.Int) ->
                           case b1 of b2 { GHC.Types.W# ipv2 ->
                           case i of i1 { GHC.Types.I# ipv3 ->
                           case j of j1 { GHC.Types.I# ipv4 ->
                           case k of k1 { GHC.Types.I# ipv5 ->
                           case GHC.Classes.geInt k1 n of wild2 {
                             GHC.Types.False
                             -> let {
                                  ds4 :: GHC.Types.Bool
                                  = GHC.Classes.neWord
                                      (Data.Bits.$fBitsWord_$c.&. q b2)
                                      (GHC.Types.W# 0##)
                                } in
                                case GHC.Classes.neWord
                                       (Data.Bits.$fBitsWord_$c.&. p b2)
                                       (GHC.Types.W# 0##) of wild3 {
                                  GHC.Types.False
                                  -> case ds4 of wild4 {
                                       GHC.Types.False
                                       -> Data.Trie.ArrayMapped.SparseArray.__impossible
                                            @ (GHC.ST.ST
                                                 s
                                                 (Data.Trie.ArrayMapped.SparseArray.SparseArray c))
                                            (GHC.Base.build
                                               @ GHC.Types.Char
                                               (\ @ b3 ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b3
                                                  "__unionWith"#))
                                       GHC.Types.True
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$
                                               @ 'GHC.Types.PtrRepLifted
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (h (case GHC.Prim.indexArray#
                                                          @ b
                                                          ys
                                                          ipv4 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               i1
                                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#))) }
                                  GHC.Types.True
                                  -> case ds4 of wild4 {
                                       GHC.Types.False
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$
                                               @ 'GHC.Types.PtrRepLifted
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (f (case GHC.Prim.indexArray#
                                                          @ a
                                                          xs
                                                          ipv3 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# 1#))
                                               j1
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#)))
                                       GHC.Types.True
                                       -> GHC.ST.$fMonadST_$c>>
                                            @ s
                                            @ ()
                                            @ (Data.Trie.ArrayMapped.SparseArray.SparseArray c)
                                            (GHC.Base.$
                                               @ 'GHC.Types.PtrRepLifted
                                               @ c
                                               @ (GHC.ST.ST s ())
                                               (Data.Trie.ArrayMapped.SparseArray.write
                                                  @ s
                                                  @ c
                                                  zs
                                                  k1)
                                               (g (case GHC.Prim.indexArray#
                                                          @ a
                                                          xs
                                                          ipv3 of ds5 { Unit# ipv6 ->
                                                   ipv6 })
                                                  (case GHC.Prim.indexArray#
                                                          @ b
                                                          ys
                                                          ipv4 of ds5 { Unit# ipv6 ->
                                                   ipv6 })))
                                            (go
                                               (let {
                                                  p1 :: Data.Trie.ArrayMapped.SparseArray.Bitmap
                                                  = Data.Bits.$fBitsWord_$c.&.
                                                      r
                                                      (GHC.Num.$fNumWord_$cnegate
                                                         (GHC.Types.W#
                                                            (GHC.Prim.uncheckedShiftL# ipv2 1#)))
                                                } in
                                                Data.Bits.$fBitsWord_$c.&.
                                                  p1
                                                  (GHC.Num.$fNumWord_$cnegate p1))
                                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# 1#))
                                               (GHC.Num.$fNumInt_$c+ k1 (GHC.Types.I# 1#))) } }
                             GHC.Types.True
                             -> Data.Trie.ArrayMapped.SparseArray.unsafeFreeze
                                  @ s
                                  @ c
                                  r
                                  zs } } } } }
                       } in
                       go
                         (Data.Trie.ArrayMapped.SparseArray.getFirstBit r)
                         (GHC.Types.I# 0#)
                         (GHC.Types.I# 0#)
                         (GHC.Types.I# 0#))) } } } }) -}
ce232f36b732cea9a0f46491c76dff2d
  unsafeFreeze ::
    Data.Trie.ArrayMapped.SparseArray.Bitmap
    -> GHC.Prim.MutableArray# s a
    -> GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U(U)><S,U><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   (p :: Data.Trie.ArrayMapped.SparseArray.Bitmap)
                   (xs :: GHC.Prim.MutableArray# s a) ->
                 case p of p1 { GHC.Types.W# ipv ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.ST.STRep
                        s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                   @ (GHC.ST.ST s (Data.Trie.ArrayMapped.SparseArray.SparseArray a))
                   (\ (tpl :: GHC.ST.STRep
                                s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)) ->
                    tpl)
                     `cast`
                   (<GHC.ST.STRep
                       s (Data.Trie.ArrayMapped.SparseArray.SparseArray a)>_R
                    ->_R Sym (GHC.ST.N:ST[0]
                                  <s>_N <Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R))
                   (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                    case GHC.Prim.unsafeFreezeArray#
                           @ s
                           @ a
                           xs
                           s1 of ds { (#,#) ipv1 ipv2 ->
                    (# ipv1,
                       Data.Trie.ArrayMapped.SparseArray.SA @ a ipv ipv2 #) }) }) -}
3eaf97b0595cf90c6b9224f46963bb30
  viewSubsingleton ::
    Data.Trie.ArrayMapped.SparseArray.SparseArray a
    -> Data.Trie.ArrayMapped.SparseArray.SubsingletonView a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
                 case xz of wild { Data.Trie.ArrayMapped.SparseArray.SA dt xs ->
                 case Data.Bits.$fBitsWord_$cpopCount
                        (GHC.Types.W# dt) of wild1 { GHC.Types.I# ds ->
                 case ds of ds1 {
                   DEFAULT -> Data.Trie.ArrayMapped.SparseArray.IsNotSubsingleton @ a
                   0# -> Data.Trie.ArrayMapped.SparseArray.IsEmpty @ a
                   1#
                   -> case GHC.Prim.indexArray# @ a xs 0# of ds2 { Unit# ipv ->
                      case (Data.Trie.ArrayMapped.SparseArray.c_ffs
                              (GHC.Int.I32# (GHC.Prim.narrow32Int# (GHC.Prim.word2Int# dt)))
                                `cast`
                              (Sym (Foreign.C.Types.N:CInt[0])))
                             `cast`
                           (Foreign.C.Types.N:CInt[0]) of wild2 { GHC.Int.I32# x# ->
                      Data.Trie.ArrayMapped.SparseArray.IsSingleton
                        @ a
                        (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# x#))
                        ipv } } } } }) -}
4688f3cc4887a6ba3cd878affc7ebad9
  write ::
    GHC.Prim.MutableArray# s a
    -> Data.Trie.ArrayMapped.SparseArray.Index -> a -> GHC.ST.ST s ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><S(S),1*U(U)><L,U><S,U>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ s
                   @ a
                   (xs :: GHC.Prim.MutableArray# s a)
                   (_i :: Data.Trie.ArrayMapped.SparseArray.Index)
                   (x :: a) ->
                 case _i of wild { GHC.Types.I# i ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (GHC.ST.STRep s ())
                   @ (GHC.ST.ST s ())
                   (\ (tpl :: GHC.ST.STRep s ()) -> tpl)
                     `cast`
                   (<GHC.ST.STRep s ()>_R ->_R Sym (GHC.ST.N:ST[0] <s>_N <()>_R))
                   (\ (s1 :: GHC.Prim.State# s)[OneShot] ->
                    case GHC.Prim.writeArray# @ s @ a xs i x s1 of s' { DEFAULT ->
                    (# s', GHC.Tuple.() #) }) }) -}
instance Data.Binary.Class.Binary [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fBinarySparseArray
instance GHC.Classes.Eq [Data.Trie.ArrayMapped.SparseArray.DynamicSA]
  = Data.Trie.ArrayMapped.SparseArray.$fEqDynamicSA
instance GHC.Classes.Eq [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fEqSparseArray
instance GHC.Classes.Eq [Data.Trie.ArrayMapped.SparseArray.SubsingletonView]
  = Data.Trie.ArrayMapped.SparseArray.$fEqSubsingletonView
instance Data.Foldable.Foldable [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fFoldableSparseArray
instance GHC.Base.Functor [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fFunctorSparseArray
instance Control.DeepSeq.NFData [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fNFDataSparseArray
instance GHC.Classes.Ord [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fOrdSparseArray
instance GHC.Show.Show [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fShowSparseArray
instance GHC.Show.Show [Data.Trie.ArrayMapped.SparseArray.SubsingletonView]
  = Data.Trie.ArrayMapped.SparseArray.$fShowSubsingletonView
instance Data.Traversable.Traversable [Data.Trie.ArrayMapped.SparseArray.SparseArray]
  = Data.Trie.ArrayMapped.SparseArray.$fTraversableSparseArray
"filter (const False)" [ALWAYS] forall @ a
  Data.Trie.ArrayMapped.SparseArray.filter @ a
                                           (\ (ds :: a) -> GHC.Types.False)
  = GHC.Base.const
      @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
      @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
      (Data.Trie.ArrayMapped.SparseArray.empty @ a)
"filter (const True)" [ALWAYS] forall @ a
  Data.Trie.ArrayMapped.SparseArray.filter @ a
                                           (\ (ds :: a) -> GHC.Types.True)
  = GHC.Base.id @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
"filter . filter" [ALWAYS] forall @ a
                                  (f :: a -> GHC.Types.Bool)
                                  (g :: a -> GHC.Types.Bool)
                                  (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.filter @ a
                                           f
                                           (Data.Trie.ArrayMapped.SparseArray.filter @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filter
      @ a
      (\ (x :: a) -> GHC.Classes.&& (g x) (f x))
      xs
"filter . filterMap" [ALWAYS] forall @ a
                                     @ b
                                     (f :: b -> GHC.Types.Bool)
                                     (g :: a -> GHC.Base.Maybe b)
                                     (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.filter @ b
                                           f
                                           (Data.Trie.ArrayMapped.SparseArray.filterMap
                                              @ a
                                              @ b
                                              g
                                              xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       let {
         fail :: GHC.Prim.Void# -> GHC.Base.Maybe b {- Arity: 1 -}
         = \ (ds :: GHC.Prim.Void#)[OneShot] -> GHC.Base.Nothing @ b
       } in
       case g x of wild {
         GHC.Base.Nothing -> fail GHC.Prim.void#
         GHC.Base.Just y
         -> case f y of wild1 {
              GHC.Types.False -> fail GHC.Prim.void# GHC.Types.True -> wild } })
      xs
"filter . map" [ALWAYS] forall @ a
                               @ b
                               (f :: b -> GHC.Types.Bool)
                               (g :: a -> b)
                               (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.filter @ b
                                           f
                                           (Data.Trie.ArrayMapped.SparseArray.map @ a @ b g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       let {
         y :: b = g x
       } in
       case f y of wild {
         GHC.Types.False -> GHC.Base.Nothing @ b
         GHC.Types.True -> GHC.Base.Just @ b y })
      xs
"filter . map'" [ALWAYS] forall @ a
                                @ b
                                (f :: b -> GHC.Types.Bool)
                                (g :: a -> b)
                                (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.filter @ b
                                           f
                                           (Data.Trie.ArrayMapped.SparseArray.map' @ a @ b g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       let {
         y :: b = g x
       } in
       case GHC.Base.$! @ b @ GHC.Types.Bool f y of wild {
         GHC.Types.False -> GHC.Base.Nothing @ b
         GHC.Types.True -> GHC.Base.Just @ b y })
      xs
"filterMap (Just . f)" [ALWAYS] forall @ t @ b (f :: t -> b)
  Data.Trie.ArrayMapped.SparseArray.filterMap @ t
                                              @ b
                                              (\ (x :: t) -> GHC.Base.Just @ b (f x))
  = Data.Trie.ArrayMapped.SparseArray.map @ t @ b f
"filterMap (const Nothing)" [ALWAYS] forall @ a @ b
  Data.Trie.ArrayMapped.SparseArray.filterMap @ a
                                              @ b
                                              (\ (ds :: a) -> GHC.Base.Nothing @ b)
  = GHC.Base.const
      @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
      @ (Data.Trie.ArrayMapped.SparseArray.SparseArray a)
      (Data.Trie.ArrayMapped.SparseArray.empty @ b)
"filterMap . filter" [ALWAYS] forall @ a
                                     @ b
                                     (f :: a -> GHC.Base.Maybe b)
                                     (g :: a -> GHC.Types.Bool)
                                     (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.filterMap @ a
                                              @ b
                                              f
                                              (Data.Trie.ArrayMapped.SparseArray.filter @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       case g x of wild {
         GHC.Types.False -> GHC.Base.Nothing @ b GHC.Types.True -> f x })
      xs
"filterMap . filterMap" [ALWAYS] forall @ a
                                        @ a1
                                        @ b
                                        (f :: a -> GHC.Base.Maybe b)
                                        (g :: a1 -> GHC.Base.Maybe a)
                                        (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.filterMap @ a
                                              @ b
                                              f
                                              (Data.Trie.ArrayMapped.SparseArray.filterMap
                                                 @ a1
                                                 @ a
                                                 g
                                                 xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a1
      @ b
      (\ (x :: a1) ->
       GHC.Base.=<<
         @ GHC.Base.Maybe
         @ a
         @ b
         GHC.Base.$fMonadMaybe
         f
         (g x))
      xs
"filterMap . map" [ALWAYS] forall @ a
                                  @ a1
                                  @ b
                                  (f :: a -> GHC.Base.Maybe b)
                                  (g :: a1 -> a)
                                  (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.filterMap @ a
                                              @ b
                                              f
                                              (Data.Trie.ArrayMapped.SparseArray.map @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a1
      @ b
      (\ (x :: a1) -> f (g x))
      xs
"filterMap . map'" [ALWAYS] forall @ a
                                   @ a1
                                   @ b
                                   (f :: a -> GHC.Base.Maybe b)
                                   (g :: a1 -> a)
                                   (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.filterMap @ a
                                              @ b
                                              f
                                              (Data.Trie.ArrayMapped.SparseArray.map' @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a1
      @ b
      (\ (x :: a1) -> GHC.Base.$! @ a @ (GHC.Base.Maybe b) f (g x))
      xs
"filterMap Just" [ALWAYS] forall @ b
  Data.Trie.ArrayMapped.SparseArray.filterMap @ b
                                              @ b
                                              (GHC.Base.Just @ b)
  = GHC.Base.id @ (Data.Trie.ArrayMapped.SparseArray.SparseArray b)
"map . filter" [ALWAYS] forall @ a
                               @ b
                               (f :: a -> b)
                               (g :: a -> GHC.Types.Bool)
                               (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.map @ a
                                        @ b
                                        f
                                        (Data.Trie.ArrayMapped.SparseArray.filter @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       case g x of wild {
         GHC.Types.False -> GHC.Base.Nothing @ b
         GHC.Types.True -> GHC.Base.Just @ b (f x) })
      xs
"map . filterMap" [ALWAYS] forall @ a
                                  @ a1
                                  @ b
                                  (f :: a -> b)
                                  (g :: a1 -> GHC.Base.Maybe a)
                                  (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map @ a
                                        @ b
                                        f
                                        (Data.Trie.ArrayMapped.SparseArray.filterMap @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a1
      @ b
      (\ (x :: a1) ->
       Data.Functor.<$>
         @ GHC.Base.Maybe
         @ a
         @ b
         GHC.Base.$fFunctorMaybe
         f
         (g x))
      xs
"map . map" [ALWAYS] forall @ a
                            @ a1
                            @ b
                            (f :: a -> b)
                            (g :: a1 -> a)
                            (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map @ a
                                        @ b
                                        f
                                        (Data.Trie.ArrayMapped.SparseArray.map @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.map
      @ a1
      @ b
      (\ (x :: a1) -> f (g x))
      xs
"map . map'" [ALWAYS] forall @ a
                             @ a1
                             @ b
                             (f :: a -> b)
                             (g :: a1 -> a)
                             (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map @ a
                                        @ b
                                        f
                                        (Data.Trie.ArrayMapped.SparseArray.map' @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.map
      @ a1
      @ b
      (\ (x :: a1) -> GHC.Base.$! @ a @ b f (g x))
      xs
"map' . filter" [ALWAYS] forall @ a
                                @ b
                                (f :: a -> b)
                                (g :: a -> GHC.Types.Bool)
                                (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a)
  Data.Trie.ArrayMapped.SparseArray.map' @ a
                                         @ b
                                         f
                                         (Data.Trie.ArrayMapped.SparseArray.filter @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a
      @ b
      (\ (x :: a) ->
       case g x of wild {
         GHC.Types.False -> GHC.Base.Nothing @ b
         GHC.Types.True
         -> GHC.Base.$!
              @ b
              @ (GHC.Base.Maybe b)
              (GHC.Base.Just @ b)
              (f x) })
      xs
"map' . filterMap" [ALWAYS] forall @ a
                                   @ a1
                                   @ b
                                   (f :: a -> b)
                                   (g :: a1 -> GHC.Base.Maybe a)
                                   (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map' @ a
                                         @ b
                                         f
                                         (Data.Trie.ArrayMapped.SparseArray.filterMap @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.filterMap
      @ a1
      @ b
      (\ (x :: a1) ->
       case g x of wild {
         GHC.Base.Nothing -> GHC.Base.Nothing @ b
         GHC.Base.Just y
         -> GHC.Base.$!
              @ b
              @ (GHC.Base.Maybe b)
              (GHC.Base.Just @ b)
              (f y) })
      xs
"map' . map" [ALWAYS] forall @ a
                             @ a1
                             @ b
                             (f :: a -> b)
                             (g :: a1 -> a)
                             (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map' @ a
                                         @ b
                                         f
                                         (Data.Trie.ArrayMapped.SparseArray.map @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.map'
      @ a1
      @ b
      (\ (x :: a1) -> f (g x))
      xs
"map' . map'" [ALWAYS] forall @ a
                              @ a1
                              @ b
                              (f :: a -> b)
                              (g :: a1 -> a)
                              (xs :: Data.Trie.ArrayMapped.SparseArray.SparseArray a1)
  Data.Trie.ArrayMapped.SparseArray.map' @ a
                                         @ b
                                         f
                                         (Data.Trie.ArrayMapped.SparseArray.map' @ a1 @ a g xs)
  = Data.Trie.ArrayMapped.SparseArray.map'
      @ a1
      @ b
      (\ (x :: a1) -> GHC.Base.$! @ a @ b f (g x))
      xs
"map'/coerce" [ALWAYS] forall @ b @ a ($r$dCoercible :: a ~R# b)
  Data.Trie.ArrayMapped.SparseArray.map' @ a
                                         @ b
                                         (\ (tpl :: a) -> tpl) `cast` (<a>_R ->_R $r$dCoercible)
  = (\ (tpl :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
     tpl)
      `cast`
    (<Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
     ->_R (Data.Trie.ArrayMapped.SparseArray.SparseArray
             $r$dCoercible)_R)
"map/coerce" [ALWAYS] forall @ b @ a ($r$dCoercible :: a ~R# b)
  Data.Trie.ArrayMapped.SparseArray.map @ a
                                        @ b
                                        (\ (tpl :: a) -> tpl) `cast` (<a>_R ->_R $r$dCoercible)
  = (\ (tpl :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
     tpl)
      `cast`
    (<Data.Trie.ArrayMapped.SparseArray.SparseArray a>_R
     ->_R (Data.Trie.ArrayMapped.SparseArray.SparseArray
             $r$dCoercible)_R)
"partition (const False)" [ALWAYS] forall @ a
  Data.Trie.ArrayMapped.SparseArray.partition @ a
                                              (\ (ds :: a) -> GHC.Types.False)
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
    (Data.Trie.ArrayMapped.SparseArray.empty @ a, xz)
"partition (const True)" [ALWAYS] forall @ a
  Data.Trie.ArrayMapped.SparseArray.partition @ a
                                              (\ (ds :: a) -> GHC.Types.True)
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray a) ->
    (xz, Data.Trie.ArrayMapped.SparseArray.empty @ a)
"partitionMap (Left . f)" [ALWAYS] forall @ c @ t @ b (f :: t -> b)
  Data.Trie.ArrayMapped.SparseArray.partitionMap @ t
                                                 @ b
                                                 @ c
                                                 (\ (x :: t) -> Data.Either.Left @ b @ c (f x))
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray t) ->
    (Data.Trie.ArrayMapped.SparseArray.map @ t @ b f xz,
     Data.Trie.ArrayMapped.SparseArray.empty @ c)
"partitionMap (Right . f)" [ALWAYS] forall @ b
                                           @ t
                                           @ b1
                                           (f :: t -> b1)
  Data.Trie.ArrayMapped.SparseArray.partitionMap @ t
                                                 @ b
                                                 @ b1
                                                 (\ (x :: t) -> Data.Either.Right @ b @ b1 (f x))
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray t) ->
    (Data.Trie.ArrayMapped.SparseArray.empty @ b,
     Data.Trie.ArrayMapped.SparseArray.map @ t @ b1 f xz)
"partitionMap Left" [ALWAYS] forall @ b @ c
  Data.Trie.ArrayMapped.SparseArray.partitionMap @ b
                                                 @ b
                                                 @ c
                                                 (Data.Either.Left @ b @ c)
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray b) ->
    (xz, Data.Trie.ArrayMapped.SparseArray.empty @ c)
"partitionMap Right" [ALWAYS] forall @ b @ c
  Data.Trie.ArrayMapped.SparseArray.partitionMap @ c
                                                 @ b
                                                 @ c
                                                 (Data.Either.Right @ b @ c)
  = \ (xz :: Data.Trie.ArrayMapped.SparseArray.SparseArray c) ->
    (Data.Trie.ArrayMapped.SparseArray.empty @ b, xz)
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: unsafe
require own pkg trusted: False

