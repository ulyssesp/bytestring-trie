
==================== FINAL INTERFACE ====================
2018-07-20 18:15:24.4199049 UTC

interface bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX:Data.Trie.ArrayMapped.Convenience 8001
  interface hash: d010152600fbb373ebec20dd93fc963a
  ABI hash: 7866b7557c5787794720f27a73a3b8f0
  export-list hash: 3d678b3455d68093f9c6db5467ccd5fc
  orphan hash: 5d96925661ef7fb6c76ceab91dbfec2d
  flag hash: 3cc9ab10e7e7d38ab0ea27df1de92424
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Trie.ArrayMapped.Convenience.adjustWithKey
  Data.Trie.ArrayMapped.Convenience.disunion
  Data.Trie.ArrayMapped.Convenience.fromListL
  Data.Trie.ArrayMapped.Convenience.fromListR
  Data.Trie.ArrayMapped.Convenience.fromListS
  Data.Trie.ArrayMapped.Convenience.fromListWith
  Data.Trie.ArrayMapped.Convenience.fromListWith'
  Data.Trie.ArrayMapped.Convenience.fromListWithL
  Data.Trie.ArrayMapped.Convenience.fromListWithL'
  Data.Trie.ArrayMapped.Convenience.insertIfAbsent
  Data.Trie.ArrayMapped.Convenience.insertWith
  Data.Trie.ArrayMapped.Convenience.insertWith'
  Data.Trie.ArrayMapped.Convenience.insertWithKey
  Data.Trie.ArrayMapped.Convenience.insertWithKey'
  Data.Trie.ArrayMapped.Convenience.lookupWithDefault
  Data.Trie.ArrayMapped.Convenience.unionWith
  Data.Trie.ArrayMapped.Convenience.unionWith'
  Data.Trie.ArrayMapped.Convenience.update
  Data.Trie.ArrayMapped.Convenience.updateWithKey
module dependencies: Data.Trie.ArrayMapped.Base
                     Data.Trie.ArrayMapped.Errors Data.Trie.ArrayMapped.Internal
                     Data.Trie.ArrayMapped.SparseArray Data.Trie.ByteStringInternal
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      data-or-1.0.0.5@data-or-1.0.0.5-7fP9a913JBX6EaOUN88kxz
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:Data.OldList 3c899c6d8e6204063769214449ac0954
import  -/  base-4.9.0.0:Data.Ord f0d073170d91d9483c5cc4a834e93dcf
import  -/  base-4.9.0.0:Data.Tuple 84c2bcc75b7a239341ae2f88cce9d8d7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString 94d879de7c0c4c728d40df2175a8ec14
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Internal c4a5d5c11e9c7b86fbb578dc42b94086
import  -/  Data.Trie.ArrayMapped.Base a07e21b46fcc7a381de96af31a327ab4
  exports: aa756b2699d0c5beccfd2a1dcf830e76
  fromList 7cb385b173ff14320644d4b6158e3549
import  -/  Data.Trie.ArrayMapped.Internal f37abeb323f744e5387c76325eb06c6e
  exports: 7af6de0b773440270fdc106cc5360efc
  Trie 03bcb0def4d0999c581debeb0287d893
  adjust 327adc7feaf50963d3bab412c1d968d3
  alter 308af13d42d8c4904b051ff1d9a9b40f
  empty 03bcb0def4d0999c581debeb0287d893
  lookupBy_ 30aeb077719034a675c8e73c555aca5b
  mergeBy 839e559358da956ef0ba8cae5a663020
d7508bc46df67c58b92eb735834b3892
  $scomparing ::
    (b -> Data.ByteString.Internal.ByteString)
    -> b -> b -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SLSS)),C(U(U,U,U,U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   (p :: b -> Data.ByteString.Internal.ByteString)
                   (x :: b)
                   (y :: b) ->
                 Data.ByteString.Internal.compareBytes (p x) (p y)) -}
11cd7b56c2b3cb792a4fe4a168d58c8b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Trie.ArrayMapped.Convenience.$trModule2
                   Data.Trie.ArrayMapped.Convenience.$trModule1) -}
20d7b9afc9763db147817346253d49b5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Trie.ArrayMapped.Convenience"#) -}
4401f4aff67c49ef4707f7c51ae1cf4e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "bytestring-trie-0.3.0.3-HLFcIfm9b5G6WckdLkDVsX"#) -}
f984b001848f695f9dd676cf41897b7e
  adjustWithKey ::
    (Data.ByteString.Internal.ByteString -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U(U,U,U,U)>,
     Unfolding: (\ @ a
                   (f :: Data.ByteString.Internal.ByteString -> a -> a)
                   (q :: Data.ByteString.Internal.ByteString) ->
                 let {
                   w :: a -> a = f q
                 } in
                 \ (w2 :: Data.Trie.ArrayMapped.Internal.Trie a) ->
                 case q of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.ArrayMapped.Internal.$wadjust
                   @ a
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   w2 }) -}
8e3d87af8138fa42d18d38d6e0868d85
  disunion ::
    Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Strictness: b,
     Unfolding: InlineRule (0, True, False)
                (\ @ a ->
                 case Data.Trie.ArrayMapped.Internal.mergeBy
                 ret_ty (Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                 of {}) -}
6b1964c198d25f49cadad1a98ab2072a
  fromListL ::
    [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a ->
                 GHC.List.foldl'
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a)
                   (GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (Data.ByteString.Internal.ByteString
                         -> a
                         -> Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                      @ (Data.Trie.ArrayMapped.Internal.Trie a
                         -> (Data.ByteString.Internal.ByteString, a)
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                      (\ (x :: Data.ByteString.Internal.ByteString
                               -> a
                               -> Data.Trie.ArrayMapped.Internal.Trie a
                               -> Data.Trie.ArrayMapped.Internal.Trie a)
                         (eta :: Data.Trie.ArrayMapped.Internal.Trie a)
                         (eta1 :: (Data.ByteString.Internal.ByteString, a)) ->
                       GHC.Base.flip
                         @ (Data.ByteString.Internal.ByteString, a)
                         @ (Data.Trie.ArrayMapped.Internal.Trie a)
                         @ (Data.Trie.ArrayMapped.Internal.Trie a)
                         (Data.Tuple.uncurry
                            @ Data.ByteString.Internal.ByteString
                            @ a
                            @ (Data.Trie.ArrayMapped.Internal.Trie a
                               -> Data.Trie.ArrayMapped.Internal.Trie a)
                            x)
                         eta
                         eta1)
                      (Data.Trie.ArrayMapped.Convenience.insertIfAbsent @ a))
                   (Data.Trie.ArrayMapped.Internal.empty @ a)) -}
5c74222c6deb92f90caae7c95d706ba7
  fromListR ::
    [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Trie.ArrayMapped.Base.fromList -}
4570f3fba8daa0b1f19ee0362a7f01ed
  fromListS ::
    [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ a ->
                 let {
                   g :: (Data.ByteString.Internal.ByteString, a)
                        -> (Data.ByteString.Internal.ByteString, a) -> GHC.Types.Ordering
                     {- Arity: 2 -}
                   = Data.Trie.ArrayMapped.Convenience.$scomparing
                       @ (Data.ByteString.Internal.ByteString, a)
                       (Data.Tuple.fst @ Data.ByteString.Internal.ByteString @ a)
                 } in
                 \ (x :: [(Data.ByteString.Internal.ByteString, a)]) ->
                 GHC.Base.foldr
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a)
                   (Data.Tuple.uncurry
                      @ Data.ByteString.Internal.ByteString
                      @ a
                      @ (Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                      (Data.Trie.ArrayMapped.Base.insert @ a))
                   (Data.Trie.ArrayMapped.Internal.empty @ a)
                   (Data.OldList.sortBy
                      @ (Data.ByteString.Internal.ByteString, a)
                      g
                      x)) -}
114004a25ea8b2a7015122faf6085555
  fromListWith ::
    (a -> a -> a)
    -> [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (f :: a -> a -> a)
                   (eta :: [(Data.ByteString.Internal.ByteString, a)]) ->
                 GHC.Base.foldr
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a)
                   (\ (ds :: (Data.ByteString.Internal.ByteString, a)) ->
                    case ds of wild { (,) k v ->
                    let {
                      g :: a -> a = f v
                    } in
                    let {
                      f1 :: GHC.Base.Maybe a -> GHC.Base.Maybe a {- Arity: 1 -}
                      = \ (x :: GHC.Base.Maybe a) ->
                        GHC.Base.Just @ a (Data.Maybe.maybe @ a @ a v g x)
                    } in
                    Data.Trie.ArrayMapped.Internal.alterBy_
                      @ a
                      (\ (v1 :: a)
                         (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                       case f1 (GHC.Base.Just @ a v1) of wild1 {
                         GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                         GHC.Base.Just v2
                         -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v2 t })
                      (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                       case f1 (GHC.Base.Nothing @ a) of wild1 {
                         GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                         GHC.Base.Just v1
                         -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                      k })
                   (Data.Trie.ArrayMapped.Internal.empty @ a)
                   eta) -}
5a42b70cadf96b63577a55dd143e9545
  fromListWith' ::
    (a -> a -> a)
    -> [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (f :: a -> a -> a)
                   (eta :: [(Data.ByteString.Internal.ByteString, a)]) ->
                 GHC.Base.foldr
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a)
                   (\ (ds :: (Data.ByteString.Internal.ByteString, a)) ->
                    case ds of wild { (,) k v ->
                    let {
                      f1 :: GHC.Base.Maybe a -> GHC.Base.Maybe a {- Arity: 1 -}
                      = \ (m :: GHC.Base.Maybe a) ->
                        GHC.Base.$!
                          @ a
                          @ (GHC.Base.Maybe a)
                          (GHC.Base.Just @ a)
                          (Data.Maybe.maybe @ a @ a v (f v) m)
                    } in
                    Data.Trie.ArrayMapped.Internal.alterBy_
                      @ a
                      (\ (v1 :: a)
                         (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                       case f1 (GHC.Base.Just @ a v1) of wild1 {
                         GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                         GHC.Base.Just v2
                         -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v2 t })
                      (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                       case f1 (GHC.Base.Nothing @ a) of wild1 {
                         GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                         GHC.Base.Just v1
                         -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                      k })
                   (Data.Trie.ArrayMapped.Internal.empty @ a)
                   eta) -}
0c2dd21c75362524085a74bb829ae3d3
  fromListWithL ::
    (a -> a -> a)
    -> [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (f :: a -> a -> a)
                   (eta :: [(Data.ByteString.Internal.ByteString, a)]) ->
                 GHC.Base.foldr
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a
                      -> Data.Trie.ArrayMapped.Internal.Trie a)
                   (\ (ds :: (Data.ByteString.Internal.ByteString, a))
                      (ds1 :: Data.Trie.ArrayMapped.Internal.Trie a
                              -> Data.Trie.ArrayMapped.Internal.Trie a)[OneShot]
                      (tpl :: Data.Trie.ArrayMapped.Internal.Trie a)[OneShot] ->
                    case tpl of z { DEFAULT ->
                    ds1
                      (case ds of wild { (,) k v ->
                       let {
                         g :: a -> a {- Arity: 1 -} = \ (w :: a) -> f w v
                       } in
                       let {
                         f1 :: GHC.Base.Maybe a -> GHC.Base.Maybe a {- Arity: 1 -}
                         = \ (x :: GHC.Base.Maybe a) ->
                           GHC.Base.Just @ a (Data.Maybe.maybe @ a @ a v g x)
                       } in
                       Data.Trie.ArrayMapped.Internal.alterBy_
                         @ a
                         (\ (v1 :: a)
                            (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                          case f1 (GHC.Base.Just @ a v1) of wild1 {
                            GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                            GHC.Base.Just v2
                            -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v2 t })
                         (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                          case f1 (GHC.Base.Nothing @ a) of wild1 {
                            GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                            GHC.Base.Just v1
                            -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                         k
                         z }) })
                   (GHC.Base.id @ (Data.Trie.ArrayMapped.Internal.Trie a))
                   eta
                   (Data.Trie.ArrayMapped.Internal.empty @ a)) -}
49c79ab6d5b9b240a7e6784721c81d03
  fromListWithL' ::
    (a -> a -> a)
    -> [(Data.ByteString.Internal.ByteString, a)]
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (f :: a -> a -> a)
                   (eta :: [(Data.ByteString.Internal.ByteString, a)]) ->
                 GHC.Base.foldr
                   @ (Data.ByteString.Internal.ByteString, a)
                   @ (Data.Trie.ArrayMapped.Internal.Trie a
                      -> Data.Trie.ArrayMapped.Internal.Trie a)
                   (\ (ds :: (Data.ByteString.Internal.ByteString, a))
                      (ds1 :: Data.Trie.ArrayMapped.Internal.Trie a
                              -> Data.Trie.ArrayMapped.Internal.Trie a)[OneShot]
                      (tpl :: Data.Trie.ArrayMapped.Internal.Trie a)[OneShot] ->
                    case tpl of z { DEFAULT ->
                    ds1
                      (case ds of wild { (,) k v ->
                       let {
                         f1 :: GHC.Base.Maybe a -> GHC.Base.Maybe a {- Arity: 1 -}
                         = \ (m :: GHC.Base.Maybe a) ->
                           GHC.Base.$!
                             @ a
                             @ (GHC.Base.Maybe a)
                             (GHC.Base.Just @ a)
                             (Data.Maybe.maybe @ a @ a v (\ (w :: a)[OneShot] -> f w v) m)
                       } in
                       Data.Trie.ArrayMapped.Internal.alterBy_
                         @ a
                         (\ (v1 :: a)
                            (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                          case f1 (GHC.Base.Just @ a v1) of wild1 {
                            GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                            GHC.Base.Just v2
                            -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v2 t })
                         (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                          case f1 (GHC.Base.Nothing @ a) of wild1 {
                            GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                            GHC.Base.Just v1
                            -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                         k
                         z }) })
                   (GHC.Base.id @ (Data.Trie.ArrayMapped.Internal.Trie a))
                   eta
                   (Data.Trie.ArrayMapped.Internal.empty @ a)) -}
d0e7d435e1816e95312b96d11b9097e8
  insertIfAbsent ::
    Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (k :: Data.ByteString.Internal.ByteString) (v :: a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (Data.Trie.ArrayMapped.Internal.$WAccept @ a)
                   (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                    Data.Trie.ArrayMapped.Internal.$WAccept @ a v t)
                   k) -}
62c8c19946a80e58f9e5a03eb7708e48
  insertWith ::
    (a -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><L,U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (k :: Data.ByteString.Internal.ByteString)
                   (v :: a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v1 :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a (f v1 v) dt })
                   (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                    Data.Trie.ArrayMapped.Internal.$WAccept @ a v t)
                   k) -}
5ea0f223ae7d68b9954562fb70488237
  insertWith' ::
    (a -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><L,U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (k :: Data.ByteString.Internal.ByteString)
                   (v :: a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v1 :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case f v1 v of x1 { DEFAULT ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a x1 dt } })
                   (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                    case v of x1 { DEFAULT ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a x1 dt } })
                   k) -}
29cf1d579794fe4497eedcc94b666a37
  insertWithKey ::
    (Data.ByteString.Internal.ByteString -> a -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 3, Strictness: <L,C(C1(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ a
                   (f :: Data.ByteString.Internal.ByteString -> a -> a -> a)
                   (k :: Data.ByteString.Internal.ByteString)
                   (v :: a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v1 :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a (f k v1 v) dt })
                   (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                    Data.Trie.ArrayMapped.Internal.$WAccept @ a v t)
                   k) -}
2e199ffbf6c7b1159812decbde8adf12
  insertWithKey' ::
    (Data.ByteString.Internal.ByteString -> a -> a -> a)
    -> Data.ByteString.Internal.ByteString
    -> a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 3, Strictness: <L,C(C1(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ a
                   (f :: Data.ByteString.Internal.ByteString -> a -> a -> a)
                   (k :: Data.ByteString.Internal.ByteString)
                   (v :: a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v1 :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case f k v1 v of x1 { DEFAULT ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a x1 dt } })
                   (\ (t :: Data.Trie.ArrayMapped.Internal.Trunk a) ->
                    case v of x1 { DEFAULT ->
                    case t of dt { DEFAULT ->
                    Data.Trie.ArrayMapped.Internal.Accept @ a x1 dt } })
                   k) -}
a81fcf61cb8fbeb1b60773fabff8c1f2
  lookupWithDefault ::
    a
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> a
  {- Arity: 2, Strictness: <L,U><S(SLSS),1*U(U,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (def :: a) (eta :: Data.ByteString.Internal.ByteString) ->
                 case eta of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Data.Trie.ArrayMapped.Internal.$wlookupBy_
                   @ a
                   @ a
                   (GHC.Base.const @ a @ (Data.Trie.ArrayMapped.Internal.Trunk a))
                   (\ (ds :: Data.Trie.ArrayMapped.Internal.Trunk a) -> def)
                   ww1
                   ww2
                   ww3
                   ww4 }) -}
189d696c75918296156e712729f6a014
  unionWith ::
    (a -> a -> a)
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (f :: a -> a -> a) ->
                 case Data.Trie.ArrayMapped.Internal.mergeBy
                 ret_ty (Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                 of {}) -}
6667b89b2acbeee5d1fd858754871b5b
  unionWith' ::
    (a -> a -> a)
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (f :: a -> a -> a) ->
                 case Data.Trie.ArrayMapped.Internal.mergeBy
                 ret_ty (Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a
                         -> Data.Trie.ArrayMapped.Internal.Trie a)
                 of {}) -}
f045d9be39c85f53a8854853f5e27189
  update ::
    (a -> GHC.Base.Maybe a)
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 1, Strictness: <L,C(U)>,
     Unfolding: (\ @ a (f :: a -> GHC.Base.Maybe a) ->
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case f v of wild {
                      GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                      GHC.Base.Just v1
                      -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                   (Data.Trie.ArrayMapped.Internal.$WReject @ a)) -}
181161baf85e2854918b580c0bc438a8
  updateWithKey ::
    (Data.ByteString.Internal.ByteString -> a -> GHC.Base.Maybe a)
    -> Data.ByteString.Internal.ByteString
    -> Data.Trie.ArrayMapped.Internal.Trie a
    -> Data.Trie.ArrayMapped.Internal.Trie a
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: (\ @ a
                   (f :: Data.ByteString.Internal.ByteString -> a -> GHC.Base.Maybe a)
                   (q :: Data.ByteString.Internal.ByteString) ->
                 let {
                   ds :: a -> GHC.Base.Maybe a = f q
                 } in
                 Data.Trie.ArrayMapped.Internal.alterBy_
                   @ a
                   (\ (v :: a)
                      (t :: Data.Trie.ArrayMapped.Internal.Trunk a)[OneShot] ->
                    case ds v of wild {
                      GHC.Base.Nothing -> Data.Trie.ArrayMapped.Internal.$WReject @ a t
                      GHC.Base.Just v1
                      -> Data.Trie.ArrayMapped.Internal.$WAccept @ a v1 t })
                   (Data.Trie.ArrayMapped.Internal.$WReject @ a)
                   q) -}
"SPEC/Data.Trie.ArrayMapped.Convenience comparing @ ByteString _" [ALWAYS] forall @ b
                                                                                  ($dOrd :: GHC.Classes.Ord
                                                                                              Data.ByteString.Internal.ByteString)
  Data.Ord.comparing @ Data.ByteString.Internal.ByteString @ b $dOrd
  = Data.Trie.ArrayMapped.Convenience.$scomparing @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

